{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Tue, 25 Aug 2020 02:36:00 GMT","lastBuildDate":"Tue, 25 Aug 2020 03:06:29 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"京喜小程序体验评分优化实践","link":"https://aotu.io/notes/2020/08/25/jx-audit-grade-optimization/","description":"背景体验评分 Audits 是微信开发者工具内置的一项功能，会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。 京喜小程序作为京东战略级业务，拥有千万级别的流量入口，经过长时间的业务迭代，代码逻辑已经十分复杂臃肿，有迫切的性能优化需求。因此，结合体验评分功能，以京喜首页做试点，我们进行了一次体验评分的优化实践。目的是探索小程序体验评分的指标原则：拿到100分的小程序应该是什么样子的；同时希望借此给项目优化提供更多思路。 我会按照「了解首页评分现状，分析扣分项规则，解决扣分项」这个思路来介绍，就让我们开始吧～ 京喜首页评分现状打开小程序开发者工具-调试器-Audits，点击运行，操作页面滚一滚点一点，然后点击结束。 评分结果会根据评测页面内容差异、操作习惯、有无缓存有一定浮动，下图是京喜首页的一次评分：总分68，性能、体验、最佳实践都有扣分，合计8项扣分项，后面我们来逐条分析这些扣分项。 扣分项分析和优化1、使用了过大的 WXML 节点数目 得分标准：页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个。 页面节点指标的意义在于，过大的节点数，过多过深的节点组成，都会增加内存使用，样式重排时间更长，影响体验。 现有节点2500+，想要进行优化，首先需要了解页面各个模块的节点数分布。 如何统计每个模块的节点数呢？可以使用「控制变量法」，利用性能评测工具中，节点数超过1000时会列出节点总数的能力，我们可以在总指标超过1000的情况下，每次隐藏一个模块： ​ 目标模块节点数 = 原总节点数 - 当前节点数 （实测节点数会有小范围浮动，可以测3次取平均值） 首页的模块分析图如下： ​ （第一屏） （第二屏） 简化数据如下： 观察列表可以得到两个信息：首页分为展示状态互斥的第一屏和第二屏；列表模块的节点数是大头。 因此，我们得到优化的两个方向： 页面元素按需加载，不展示时不渲染 长列表减少元素个数 第一个优化项可以通过变量控制组件显示隐藏，按需加载卸载。 第二个优化项首先想到的是减少列表接口分页数值，比如一次请求20条数据改为请求5条。但是如果接口不支持自定义分页，还可以实现更小的分页拉取吗？ 那就自己写一个分页方法的代理吧～ 思路如下： 上方为原始请求，每次20条数据，下方为代理请求的实现，每次返回5条。灰色虚线框是真实的请求数据动作，通过维护一个全量数据，需要哪页取哪页，这是示例代码： 通过以上两个优化，可以成功的把首页的页面节点数瘦身一下了，最后我们成功达到 wxml 节点总数不大于1000的目标。 2、存在图片太大而有效显示区域较小 得分标准：图片宽高乘积 &lt;= 实际显示宽高乘积 * (设备像素比 ^ 2) 简单理解是图片尺寸太大而展示尺寸太小，导致浪费网络请求时间和内存资源。 解决方案：cdn服务商一般都支持通过参数获取不同尺寸的图片，前端可以包装一个公共方法，根据页面元素尺寸拉取合适大小的图片。 此外，补充一下图片体积的内容，除了关注图片尺寸，具体的体积大小其实更值得关注，有以下两个点可以了解下： 图片类型的选择大有文章，jpg/png/gif 还有 webp 应该怎么选呢？先放一张 google 的图 这张图里未考虑 webp，加上 webp 其他类型竞争力瞬间不足了，移动端 androd 支持率基本可用，可以考虑根据设备类型渐进式使用： 利用一些压缩技术对图片进行压缩，png 推荐 https://tinypng.com/ ，压缩尺寸可观，但对图片显示质量影响甚微。 3、存在可点击元素的响应区域过小 得分标准：可点击元素的宽高都不小于 20px 移动端操作全靠手指，过小的交互区域会带来不好的体验，可以通过增大元素响应热区的方式来优化，以下方式都可以： padding 透明的border box-shadow 4、对网络请求做必要的缓存得分标准：3 分钟以内同一个url请求不出现两次回包大于 128KB 且一模一样的内容 这一项的理由是，发起网络请求总会让用户等待，可能造成不好的体验，应尽量避免多余的请求，比如对同样的请求进行缓存。 优化方式： 善用小程序的 storage 能力，做好更新和过期管理后，尽可能缓存请求到的数据。 针对确实需要多次请求的日志类接口，可以通过在参数内添加随机数或者时间戳的方式进行区分，避免误判。 5、存在短时间内发起太多的请求得分标准：通过wx.request发起的耗时超过 300ms 的请求并发数不超过 10 个。 不同于上一项，这一项关注的是接口并发数： wx.request （HTTP 连接）的最大并发限制是 10 个 wx.connectSocket （WebSocket 连接）的最大并发限制是 5 个 优化方式： 计算逻辑后移， 接口聚合 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端 6、存在未绑定在wxml上的变量 得分标准：setData传入的所有数据都在模板渲染中有相关依赖 这一项考察的是 data 冗余的问题，小程序设计了渲染和逻辑分离的双线程，两边通讯通过 evaluateJavascript 转换字符串再进行拼接实现，需要非常小心两个线程之间通讯的数据量。因此，未绑定wxml的变量，最好优化成不使用 setData。 根据使用场景，可以做的优化有： 与页面展示无关的内部变量，可以挂载在组件实例上，比如维护一个 this.privateData 对象 使用小程序新版本支持的「纯数据字段」：该字段不会被传递到 wxml 内，配置正则划定它的匹配范围，可以正常使用 setData 方法，具体用法参见文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html 但是，如果你像我一样遇到上面策略无法覆盖的场景呢？ 需要修改旧代码，配置纯数据字段的正则影响太大 京喜首页使用了 Taro 做多端适配，Taro 编译复杂逻辑的数组后会出现「影子变量」去代理逻辑，原本的数组变量被架空导致扣分 那么还有一个终极 hack 的方法： 这样 list 会被判断为有绑定节点，就不会扣分了 7、发起太多的图片请求得分标准：同域名耗时超过 100ms 的图片请求并发数不超过 20 个 最后这一项也是图片相关，发起太多图片请求会触发浏览器并行加载的限制，可能导致图片加载慢，用户一直处于等待中。 优化方式： 雪碧图 图片懒加载：小程序 Image 组件支持通过配置 lazy-load 参数来实现懒加载（https://developers.weixin.qq.com/miniprogram/dev/component/image.html ），具体判定逻辑是图片进入上下三屏就开始加载。如果需要更可控的实现，可以自己构建组件来处理。 总结做完这些优化，再测一下体验评分： 以上就是京喜首页在小程序体验评分优化方面进行的实践内容了。 总结一下，小程序性能评分可以从指标和实际数据上给我们的项目优化提供一些建议，本文主要从评分角度去分析了各种优化可能，希望能为各位小程序开发者带来参考价值。 参考资料[1] 小程序开发文档：https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B [2] Images: Your easiest page speed win: https://searchengineland.com/images-easiest-page-speed-win-269742 [3] Tiny Png: https://tinypng.com/","pubDate":"Tue, 25 Aug 2020 02:36:00 GMT","guid":"https://aotu.io/notes/2020/08/25/jx-audit-grade-optimization/","category":"小程序"},{"title":"Design Tokens —— 设计与开发碰撞的火花","link":"https://aotu.io/notes/2020/08/18/design-tokens/","description":"前言在前端的开发的过程中，和前端合作最紧密的职位应该就是设计师了。在业务流程中，设计师将自己的交互稿、视觉稿以 1px 以内误差的期望交给开发者。但在这个过程中有几个不方便的地方： 设计稿可拆解为布局、图案、文字、颜色等。其中布局、文字以及颜色这三者的样式编码需要花费前端开发者大量的时间。虽说近几年随着蓝湖等设计协同工作平台的诞生，可以在平台上获取到部分 css 代码，但是依然不能满足 web、iOS、Android 等多平台的情况； 设计稿的更新无法及时在开发者的代码中体现，一是因为开发首先需要拿到新的设计稿，再根据标注甚至肉眼判断区别后更新代码；另一方面，设计稿中看似简单的改动可能导致较大范围的代码改动，例如字体大小等。 为了解决上述的问题，完善设计和开发之间的协作流程，Design Tokens 应运而生。 什么是 Design Tokens在了解 Design Tokens 之前，需要先了解一下 Design System （即设计系统）的概念。这个概念在设计和开发的沟通流程中已经流行许久，在团队设计体系工程化的过程中不可或缺。 A Design System is the single source of truth which groups all the elements that will allow the teams to design, realize and develop a product. 设计系统能够保证项目中设计稿与开发代码的一致——设计师将设计稿件中的内容组件化，在这个系统中上传每个组件的样式、文字属性、颜色色值等。而开发者可以通过这个系统获取自己需要的组件内容。但是这样仅仅是实现了一个协作平台，那么如何解决前文提到的两个问题呢？ Design Tokens 就是解决问题的核心。 Design tokens are the visual design atoms of the design system. Design Tokens 统一了样式属性和前端语言，把每种属性都当成是一个前端变量。 举个例子，将一种颜色色值传到系统中，然后转换成 token ，前端就可以直接取这个变量使用。即使是色值被修改，当变量名不变时，对整体代码是毫无影响的，开发者要做的仅仅是重新导入一份 token。 其中 token 的语言类型可以是 css、scss、yml 等。 如何开发 Design Tokens在已知 Design Tokens 本质是一种变量的情况下，我们需要做的就是将颜色色值和文字属性变成对应的变量。 其中文字属性有比较特别的地方，它除了要把 font-family、font-size 等转换成变量之外，还需要将这些变量集合在一个 mixin 里面，方便整体使用。 所以我们需要完成的事情有如下四步，获取属性、生成变量、生成 mixin 、输出结果。其中获取属性不用多说，直接从数据库中拿到色值和文字的数据，然后分别写入 json 文件保存即可。 1.生成变量我们转换的变量类型有 css、scss、less、stylus、json、yaml、Android、iOS 八种，其中 css、scss、less、stylus、Android 这五种通过 Theo 库来实现，其余为代码手动实现。 Theo先来介绍一下 Theo,一个能够对样式进行 transform 和 format，随后输出对应变量的库。它的实现原理大致为，先将 json 文件中的值进行处理——色值处理为 rgb 或者 rgba，其余样式属性的数值进行单位统一。随后将处理过的值依据一定规则写入一个新的对象中。这个对象就是 Design Tokens。 直接上代码： 123456789101112131415161718192021static async formatWebOrtAndroid (type: string) &#123; const res = await theo .convert(&#123; transform: &#123; // 这里是类型，可以是 web或者是 android type: 'web', file: path.resolve(__dirname, 'data.json'), &#125;, format: &#123; // 这里是需要输出的变量语言类型，css、scss、less、stylus、Android 等 type, &#125; &#125;) .then(data =&gt; &#123; // 这里可以根据自己的需求进行数据处理 return data &#125;) .catch(error =&gt; console.log(`Something went wrong: $&#123;error&#125;`)) return res&#125; 自定义方法其余的 json、yaml、iOS 这三种需要我们手动实现。json 和 yaml 的实现非常简单，只需要稍微处理一下数据为我们需要的格式，然后写入 json 或者 yaml 文件即可。 iOS 略微复杂，它支持 Objective-c 和 Swift 两种类型的语言，所以要分别处理这两种语言。 Objective-c 需要分为 .h 和 .m 两个文件，对色值进行如下处理： 12345678910// 先将变量名称写入let colorsH += `- (UIColor *)$&#123;colorName&#125;;\\n`// 处理对应的变量名称下的色值let colorsM += `- (UIColor *)$&#123;colorName&#125; &#123;return [UIColor colorWithRed:($&#123;red&#125;)/255 green:($&#123;green&#125;)/255 blue:($&#123;blue&#125;)/255 alpha:($&#123;alpha&#125;)];&#125;\\n\\n`// 处理首尾colorsH = `@interface UIColor (Colors)\\n\\n$&#123;colorsH&#125;\\n@end`colorsM = `#import \"designTokenColor.h\"\\n\\n@implementation UIColor (Colors)\\n\\n$&#123;colorsM&#125;\\n@end\\n` Swift 的处理方法类似，直接上代码： 12345// 先将变量名称写入，并处理色值let colorsSwift += `class func $&#123;colorName&#125;() -&gt; UIColor&#123;\\nreturn UIColor( red: ($&#123;red&#125;)/255, green: ($&#123;green&#125;)/255, blue: ($&#123;blue&#125;)/255, alpha: ($&#123;alpha&#125;) );&#125;\\n\\n`colorsSwift = `import UIKit;\\n\\nextension UIColor&#123;\\n\\n$&#123;colorsSwift&#125;\\n&#125;\\n` 其实上述的自定义方法也可以直接定义在 Theo 中，因为 Theo 支持注册自定义 transform 事件以及自定义 format 事件，并且可以对获取到的数据进行二次处理。 2.生成 mixinmixin 是 scss 中的名称，其实就是变量的集合，能够使得一系列属性能够被整体应用。由于 Theo 没有提供对应方法，所以我们这边采用手动生成的方式。目前只针对我们需要使用的文字属性进行了构建。 我们在第一步时已经生成了所有属性的变量，所以在构建 mixin 时只需将对应变量组合在一起即可，工作量并不大。但是由于需要构建的语言类型较多，针对不同语言要输出不同格式，所以依然写了部分相似代码。 以下为不同语言下的内容生成代码： css 12345678910111213--aotu: &#123; font-family: var(--aotu-font-family); font-size: var(--aotu-font-size); font-style: var(--aotu-font-style); font-weight: var(--aotu-font-weight); letter-spacing: var(--aotu-letter-spacing); line-height: var(--aotu-line-height); opacity: var(--aotu-opacity); text-align: var(--aotu-text-align); color: var(--aotu-text-color); text-decoration: var(--aotu-text-decoration); text-transform: var(--aotu-text-transform);&#125;; scss 12345678910111213@mixin aotu () &#123; font-family: $aotu-font-family; font-size: $aotu-font-size; font-style: $aotu-font-style; font-weight: $aotu-font-weight; letter-spacing: $aotu-letter-spacing; line-height: $aotu-line-height; opacity: $aotu-opacity; text-align: $aotu-text-align; color: $aotu-text-color; text-decoration: $aotu-text-decoration; text-transform: $aotu-text-transform;&#125; less 12345678910111213.aotu () &#123; font-family: @aotu-font-family; font-size: @aotu-font-size; font-style: @aotu-font-style; font-weight: @aotu-font-weight; letter-spacing: @aotu-letter-spacing; line-height: @aotu-line-height; opacity: @aotu-opacity; text-align: @aotu-text-align; color: @aotu-text-color; text-decoration: @aotu-text-decoration; text-transform: @aotu-text-transform;&#125; Android 12345678910111213// 这里采用的是一个对象，这个对象中包含了各种数值&lt;style name=$&#123;aotu.name&#125;&gt; &lt;item name=\"android:fontFamily\"&gt;$&#123;aotu.fontFamily&#125;&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;$&#123;aotu.fontSize&#125;&lt;/item&gt; &lt;item name=\"android:letterSpacing\"&gt;$&#123;aotu.letterSpacing&#125;&lt;/item&gt; &lt;item name=\"android:lineHeight\"&gt;$&#123;aotu.lineHeight&#125;&lt;/item&gt; &lt;item name=\"android:textStyle\"&gt;$&#123;aotu.fontStyle&#125;&lt;/item&gt; &lt;item name=\"android:textFontWeight\"&gt;$&#123;aotu.fontWeight&#125;&lt;/item&gt; &lt;item name=\"android:gravity\"&gt;$&#123;aotu.textAlign&#125;&lt;/item&gt; &lt;item name=\"android:textAllCaps\"&gt;$&#123;aotu.textTransform === 'uppercase'&#125;&lt;/item&gt; &lt;item name=\"android:alpha\"&gt;$&#123;aotu.opacity&#125;&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;$&#123;aotu.color&#125;&lt;/item&gt;&lt;/style&gt; 至此，Design Tokens 的生成已经完成。 3.输出结果我们将输出的各种语言结果保存在不同文件中，上传到服务器，将内容和获取链接返回给用户。用户可以直接通过链接下载文件进行使用，也可手动复制内容到自己的项目中进行使用。当设计师改变设计稿时，他们需要重新上传组件内容，Design Tokens 的内容也会随之改变。而对于开发者来说，只需要重新导入一个新的链接，就可以直接完成大量代码的更新，大大提升了设计师以及开发者的效率，减少了开发者的重复工作，降低了双方沟通成本和版本迭代成本。 Design Tokens 应用Design Tokens 已经被应用在凹凸的工作流中。 一个项目开启的时候，需要先在内部夸克平台创建一个项目，项目成员包括设计师与前端开发。随后设计师使用夸克平台提供的 Sketch 插件将项目中需要的色值和本文样式都保存到项目中。以下为插件中展示效果： 设计师完成上述步骤后，开发者进入夸克平台，在对应项目中可查看色值和文字样式。其中可以看到每个属性对应的变量名，并且可以对变量名作出修改。 所有的 Design Tokens 会集中展示在单独页面中，其中包括了下载链接，开发者直接通过链接下载内容，然后应用到自己的项目代码中即可。 总结Design System 可能会是将来设计师与开发者合作的一种模式，目前相应的应用还不是非常广泛。并且一些小项目中，大家更倾向于口头交流、文件交流等，而不是花时间先去构建一个设计系统。但是随着公司或者部门项目扩张，积累变多，一个完善的设计系统以及高效的沟通平台将会是必须的。Design System 以及 Design Tokens 给我们带来了新的方式和新的可能，我们将会继续探索它。","pubDate":"Tue, 18 Aug 2020 11:44:02 GMT","guid":"https://aotu.io/notes/2020/08/18/design-tokens/","category":"Web开发"},{"title":"使用react-docgen自动生成组件文档","link":"https://aotu.io/notes/2020/07/27/how-to-use-react-docgen/","description":"背景最近在接到一个开发 React 组件库的需求，组件库在开发过程中，刚写完一个组件打算给同事用，同事立马来了个灵魂拷问“啊？这个组件怎么用”。emmm，我寻思直接告诉它下一次又忘了，还是老老实实写个文档吧。 文档写到一半，@#%#¥……#@麻烦死了。这么多组件，每个组件都需要有对应的文档，写起来太耗时了，手写文档比写个组件还麻烦。为了能快点完（xia）成（ban）任（hui）务（jia）。于是研究下那些优秀的组件库到底是怎么做的，看了下京东凹凸实验室的Quark夸克组件库的文档生成，大受启发，以下内容是讲讲关于如何优雅地偷懒并把组件文档都做好的。 为什么要自动生成文档聊这个事情之前，我们先看看文档希望长什么样子 组件文档需要什么内容 提供组件的介绍说明 提供组件的属性列表 propTypes 提供组件调用的案例 usage 提供组件调用的演示案例/源码 如果要把这些内容都通过 markdown 去写，写完耗费的时间可能比做一个简单的组件还多，为了把更多的精力投入到开发更优质的组件当中，我们需要文档生成自动化。 文档自动化后能为我们带来什么？ 统一文档格式，抹平不同开发者写文档的格式差异 节省写文档的时间来做更多有意（tou）义（lan）的事情 我们拿一个小案例来尝试一下 react-docgen开始进入正题，先简单介绍下文档自动生成的主角 react-docgen ，官方对于它的介绍是这样的： react-docgen 是一个 CLI 和工具箱，可帮助从 React 组件中提取信息并从中生成文档。它使用 ast 类型和@ babel / parser 将源解析为 AST，并提供处理此 AST 的方法以提取所需的信息。输出/返回值是一个 JSON blob / JavaScript 对象。 简单来说就是：它能提取组件的相关信息 安装用 yarn 或 npm 安装模块： 123yarn add react-docgen --devnpm install --save-dev react-docgen 关于它的 API 可以参考官方文档 https://www.npmjs.com/package/react-docgen 偷偷再分享一个高级版的 react-styleguidist https://github.com/styleguidist/react-styleguidist 例子我们先写一个人物的组件，里面包含 姓名、爱好、事件回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./Persion/index.jsximport React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'/*** 人物组件* @description 这是关于人物组件的描述内容* @class Persion* @extends &#123;Component&#125;*/class Persion extends Component &#123; /** * 处理睡觉的回调 * @param &#123;string&#125; name 姓名 */ handleSleep = (name) =&gt; &#123; console.log(`$&#123;name&#125; 开始睡觉`) this.props.onSleep() &#125; render() &#123; const &#123; name, hobbies &#125; = this.props return ( &lt;div onClick=&#123;this.handleSleep.bind(this, name)&#125;&gt; &lt;p&gt;姓名：&#123;name&#125;&lt;/p&gt; &lt;p&gt;爱好：&#123;hobbies.join(',')&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;Persion.propTypes = &#123; /** * 姓名 */ name: PropTypes.string.isRequired, /** * 爱好 */ hobbies: PropTypes.array, /** * 睡觉的事件回调 */ onSleep: PropTypes.func&#125;Persion.defaultProps = &#123; name: '张三', hobbies: ['睡觉', '打王者']&#125;export default Persion 我们定义了一个人物的组件，在组件类注释中描述了组件的基本信息, 同时在propTypes和defaultTypes中也对组件的属性参数进行了定义和属性注释 组件的基本信息都写的差不多了，那么我们先开始使用react-docgen去提取组件的相关信息。 12345678910111213// ./docgen.jsconst path = require('path')const fs = require('fs-extra')const reactDocs = require('react-docgen')const prettier = require('prettier')// 读取文件内容const content = fs.readFileSync(path.resolve('./Persion/index.jsx'), 'utf-8')// 提取组件信息const componentInfo = reactDocs.parse(content)// 打印信息console.log(componentInfo) 这里写了一个简单的读取文件和解析的过程，并把提取到的信息打印出来，以下是组件信息提取后的内容 componentInfo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; \"description\":\" 人物组件 @description 这是关于人物组件的描述内容 @class Persion @extends &#123;Component&#125;\" , \"displayName\":\"Persion\", \"methods\":[ &#123; \"name\":\"handleSleep\", \"docblock\":\" 处理睡觉的回调 @param name 姓名 \", \"modifiers\":[ ], \"params\":[ &#123; \"name\":\"name\", \"description\":\"姓名\", \"type\":&#123; \"name\":\"string\" &#125;, \"optional\":false &#125; ], \"returns\":null, \"description\":\"处理睡觉的回调\" &#125; ], \"props\":&#123; \"name\":&#123; \"type\":&#123; \"name\":\"string\" &#125;, \"required\":false, \"description\":\"姓名\", \"defaultValue\":&#123; \"value\":\"'张三'\", \"computed\":false &#125; &#125;, \"hobbies\":&#123; \"type\":&#123; \"name\":\"array\" &#125;, \"required\":false, \"description\":\"爱好\", \"defaultValue\":&#123; \"value\":\"['睡觉', '打王者']\", \"computed\":false &#125; &#125;, \"onSleep\":&#123; \"type\":&#123; \"name\":\"func\" &#125;, \"required\":false, \"description\":\"睡觉的事件回调\" &#125; &#125;&#125; 关于 react-docgen 提取的信息中，解释下下面几个参数 displayName 组件名称 description 组件的类注释 methods 组件定义的方法 props 组件的属性参数 其中这里的props是我们组件文档的核心内容，在提取的内容中，已经涵盖了属性的 属性名、属性描述、类型、默认值、是否必传。这些内容满足我们阅读组件文档所需要的属性信息。 有了所需的componentInfo信息之后，下一步我们需要把它转换成 markdown （至于为什么要用 markdown 我就不解释了 8） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./docgen.js// 生成markdown文档fs.writeFileSync(path.resolve('./Persion/index.md'), commentToMarkDown(componentInfo))// 把react-docgen提取的信息转换成markdown格式function commentToMarkDown(componentInfo) &#123; let &#123; props &#125; = componentInfo const markdownInfo = renderMarkDown(props) // 使用prettier美化格式 const content = prettier.format(markdownInfo, &#123; parser: 'markdown' &#125;) return content&#125;function renderMarkDown(props) &#123; return `## 参数 Props | 属性 | 类型 | 默认值 | 必填 | 描述 | | --- | --- | --- | --- | ---| $&#123;Object.keys(props) .map((key) =&gt; renderProp(key, props[key])) .join('')&#125; `&#125;function getType(type) &#123; const handler = &#123; enum: (type) =&gt; type.value.map((item) =&gt; item.value.replace(/'/g, '')).join(' \\\\| '), union: (type) =&gt; type.value.map((item) =&gt; item.name).join(' \\\\| ') &#125; if (typeof handler[type.name] === 'function') &#123; return handler[type.name](type).replace(/\\|/g, '') &#125; else &#123; return type.name.replace(/\\|/g, '') &#125;&#125;// 渲染1行属性function renderProp( name, &#123; type = &#123; name: '-' &#125;, defaultValue = &#123; value: '-' &#125;, required, description &#125;) &#123; return `| $&#123;name&#125; | $&#123;getType(type)&#125; | $&#123;defaultValue.value.replace( /\\|/g, '&lt;span&gt;|&lt;/span&gt;' )&#125; | $&#123;required ? '✓' : '✗'&#125; | $&#123;description || '-'&#125; | `&#125; 上面的转换 markdown 的代码其实做的事情比较少，主要是以下几个步骤 遍历props对象中的每个属性， 解析属性prop，提取属性名、类型、默认值、必填、描述、生成对应的 markdown 表格行。 生成 markdown 内容，通过prettier美化 markdown 代码。 经过转换后最终生成我们这个 markdown 的文件 1234567## 参数 Props| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ------ | ------------------ | ---- | -------------- || name | string | '张三' | ✗ | 姓名 || hobbies | array | ['睡觉', '打王者'] | ✗ | 爱好 || onSleep | func | - | ✗ | 睡觉的事件回调 | 拓展优化这个案例只简单讲述了如何解析props并生成 markdown 的参数 Props模块的流程，在现实项目中，以上流程还有很多可以优化的空间，我们还可以通过很多自定义规则进行各种骚操作。 比如我们不希望把参数的数据属性（name、hobbies）和回调属性（onSleep）都放到同一个 Props 表格中，我们希望可以进行属性上的分类。 在属性描述的注释中，我们可以通过 @xx （或者 ¥%#@^!【】……你喜欢就好）进行不同的描述定义和分类，最终在属性解析的步骤中进行信息的深度的拆分解析分类，生成更加复杂多元的文档。 经过一些改造后，我们通过在注释中添加不同规则的定义描述，得到更优雅美观的文档模块 1234567891011121314151617Persion.propTypes = &#123; /** * @text 姓名 * @category data */ name: PropTypes.string.isRequired, /** * @text 爱好 * @category data */ hobbies: PropTypes.array, /** * @text 睡觉的事件回调 * @category event */ onSleep: PropTypes.func&#125; 123456789101112## 数据 Data| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ------ | ------------------ | ---- | ---- || name | string | '张三' | ✗ | 姓名 || hobbies | array | ['睡觉', '打王者'] | ✗ | 爱好 |## 事件 Event| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ---- | ------ | ---- | -------------- || onSleep | func | - | ✗ | 睡觉的事件回调 | 当然还有很多比如description或者methods等都可以进行不同的解析并生成对应的markdown模块，数据信息提取出来了，其实最终怎么进行ast解析取决自身的具体业务要求。 小结在日常开发的过程中，我们除了组件的代码编写外，还有很多流程上、边角上的工作需要做，这些事情往往都比较琐碎又必须要做。我们多借助工具去解决我们的工作中那些零星简单的任务，从而达到高（jiu）效（xiang）完（kuai）成（dian）工（xia）作（ban）的目标。开发者都是懒惰的（可能只有我？？），不然怎么会有这么多自动化的产物呢～ 参考资料：[1] react-docgen 仓库文档 https://github.com/reactjs/react-docgen#readme","pubDate":"Mon, 27 Jul 2020 01:00:00 GMT","guid":"https://aotu.io/notes/2020/07/27/how-to-use-react-docgen/","category":"经验分享"},{"title":"几种移动端多平台元素垂直居中解决方案总结","link":"https://aotu.io/notes/2020/07/24/line-height-in-all-hardware/","description":"前言在PC时代，垂直居中就是一个会引起很多讨论的问题，例如经典问题：如何在任何容器里，让任意行数的元素都能垂直居中，相信很多同学对于这个问题还记忆尤深。如今移动端已经成为了我们的主要平台，随之而来的问题也更加复杂。 而作为大促前端，我们的问题更加复杂，我们需要兼容大量不同平台的手机，例如：安卓4.4系统、IOS8、IOS9等等远古手机。可能有同学很好奇为何还需要花费时间去兼容这些手机，原因很简单：数据支撑，京东大促的用户量级非常巨大，虽然这些手机用户占比很少，但是当用户基数达到一定数量时，即使占比很小，数量也是很可观的，对应而来的就是各种客诉，所以我们必须兼容这些手机。 本文将从以下场景讨论问题的解决方案。 主要诉求： 文字小于12px在安卓和ios表现不同； 文字在一定宽度下自适应，超过一定宽度需要截断； 文字配图标或者其他元素； 不使用JS，纯CSS； dom节点只有2层，比如 1&lt;div&gt;&lt;span&gt;任何元素&lt;span&gt;&lt;span class=\"tag\"&gt;内容&lt;/span&gt;&lt;/div&gt;； 必须兼容IOS9及以下和安卓4.4.4，所以首先被排除的方法就是flex布局； PS. 本文不讨论PC下的展示效果 主要问题： 假如设计稿高度为28px，我们如果把行高写成28px，那么在IOS和安卓下，必然是会出bug的，相信实践过的朋友都知道，同样的行高，IOS下没什么问题，但是在安卓下，文字是偏上的，如图所示： 经典问题了，怎么解决呢，根据网上的经验，都是建议使用flex布局的align-items来布局，但是这种布局不支持4.4.4的安卓手机，所以不行，同理grid也是不行。 方法一：table布局我尝试使用了table来进行布局，如果不考虑截断的问题，是可行的，缺点是必须2层结构，否则无法实现文字截断的效果，效果如下： 代码如下：1&lt;div class=\"word\"&gt;&lt;span&gt;文字文字文字文字文字文字&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617.word &#123; font-size: 10px; background: red; color: white; display: inline-table; padding: 0 10px; table-layout: fixed; width: 100px;&#125;.word span &#123; display: table-cell; height: 22px; vertical-align: middle; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; PS:table布局同样适用于2行纯文字，但是无法截断。 方法二：line-height: normal我们还可以使用line-height: normal的方法来实现，效果如下：代码如下：1234567891011121314.word &#123; font-size: 10px; background: red; color: white; display: inline-block; padding: 3px 10px; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.word span &#123; line-height: normal;&#125; 缺点：必须多套一层结构 PS:line-height: normal的元素不能设置高度，只能使用padding或者margin来模拟高度 方法三：？？？我们都知道，安卓下的文字是偏上的，所以我就把line-height加高了几个像素，奇迹发生了，安卓下居中了，IOS基本没变，绝了！经过试验，line-height值需要比height值大2px即可，IOS对这个值的敏感度非常小，只要不大于这个值，就几乎不变。 安卓：IOS：1234567891011121314&lt;div class=\"word\"&gt;文字文字文字文字文字文字&lt;/div&gt;.word &#123; font-size: 10px; background: red; color: white; display: inline-block; padding: 0 10px; line-height: 24px; height: 22px; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 这个方法的应用场景在哪呢，文字+icon+需要截断+自定义宽度，经过研究，我发现，这种情况下，如果不使用js或者hack，是不可能使用纯CSS的办法完美解决的，所以使用该方法，可以保证在所有安卓和IOS的差距保持在一个设计师可以接受的范围内。 效果如下：安卓：IOS：代码如下：12345678910111213141516171819202122232425262728293031.word &#123; display: inline-block; border-radius: 4px; color: #fff; background: #E8220E; text-align: left; overflow: hidden; font-size: 20px; max-width: 180px; white-space: nowrap; vertical-align: top; padding: 0 6px 0 6px; height: 28px; line-height: 32px; &amp;__pre &#123; display: inline-block; vertical-align: top; padding-right: 4px; line-height: 30px; &#125; &amp;__text &#123; display: inline-block; vertical-align: top; width: calc(100% - 20px); text-overflow: ellipsis; white-space: nowrap; overflow: hidden; table-layout: fixed; &#125;&#125; 该方法使用了calc来计算整体宽度，来实现文字截断。这种方法能够兼容一行下的大部分情况，支持图标+文字、文字+文字。缺点：IOS下可能还是会稍偏一点点，但是根据我们设计师的反馈，该误差可以接受，且该方法支持一行多个同时出现。 总结 根据实践，大部分情况下，方法3是覆盖面比较广的方法，line-height的值 &gt; height的值即可； 如果只有一行文字，建议使用line-height: normal； 多行文字建议使用table布局，控制字数，因为无法截断；","pubDate":"Fri, 24 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/24/line-height-in-all-hardware/","category":"经验分享"},{"title":"如何使用Grid Layout","link":"https://aotu.io/notes/2020/07/23/how-to-use-grid-layout/","description":"如何使用Grid Layout前言CSS Grid Layout是一种栅格布局，随着各大浏览器的兼容，在可应用范围越来越广。很多人就会问能不能代替Flexbox弹性布局？虽然他们有点相似，但值得一提的是他并不能代替Flexbox弹性布局，它可以在复杂的应用场景下与Flexbox弹性布局相辅相成。该属性的理念有点类似以往在网页设计中的栅格布局，如果以前接触过网页的栅格系统会帮助理解CSS Grid Layout。 兼容性截止到20年7月14日，caniuse的兼容图。如图所示： 应用场景先来看看应用场景，个人十分推荐它用于大型页面框架构建或者电商中的sku列表摆放。具体可以来看看这两个demo图都附录了源码地址。 Demo 链接 Demo 链接 重要属性介绍①.display: grid/inline-grid;需要在包裹子元素的父容器上做出声明，该属性声明为CSS Grid Layout有两种，一种是块状元素display: grid，一种是行内块状元素display: inline-grid。该属性声明后其他属性才会有效。如图所示： Demo 链接 ②.grid-template-areas: none/itemnames;指定一个序列进行子元素排列 ③.grid-template-rows和grid-template-columnsrows是代指行，columns是代指列，用来声明高或宽 绝对值 如%，px，vw等单位 repeat() grid-template-rows: repeat(几个, 数值); grid-template-rows: repeat(几个, 多个数值); fr 如果声明的宽度为1fr，2fr，后者是前者2倍，自动划分 auto-fill 结合repeat使用 父级宽度高度限定情况下，每个item固定宽高尽可能填充 ④.grid-gap指定栅格之间的间距 ⑤.grid-auto-flow: row/column默认是row，用于指定填满的行或列的优先级。 以上②-⑤属性可以查看这个Demo 链接 扩展阅读 CSS Grid Layout Module Level 1 CSS Grid Layout Module Level 2","pubDate":"Thu, 23 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/23/how-to-use-grid-layout/","category":"经验分享"},{"title":"移动端吸顶导航组件的实现","link":"https://aotu.io/notes/2020/07/23/mobile-top-nav/","description":"前言吸顶导航是营销会场类最常用的组件之一， 现在的会场页面是越来越长，如果从第一屏手动滑到最后一屏，还是一个挺累的操作，所以吸顶导航还是很有必要存在的，组件很常见，但是开源的不多，而且大多是PC版，几乎都不能满足业务的需求，所以决定自己写一个。 先看下组件效果 demo 功能拆解梳理下组件需要实现的功能 到达首层吸顶和最后一层取消吸顶 当前楼层高亮显示 选中导航居中显示 默认显示或滑到首层才显示 滑动过程中控制隐藏显示 展开显示更多 功能实现下面我会介绍下其中几个功能的实现方法，全部源码有兴趣的话可以点击这里 导航选中居中1. 如何居中首先我们可以先考虑怎么居左，我们知道每一项距离左边的宽度是m，那居左就是-m,居中就是再减中线的位置，中线的位置如果是M，那就是M-m。 2. 处理边界的情况通过M-m，我们再来处理到达边界的问题，主要两种情况 1.当M-m&gt;0的时候，则已经到达最左边 2.当M-m &gt;于可滚动的距离（滚动条长度-可视长度），就是到达最右边 实现代码： 1234567891011121314151617181920212223242526272829303132/*以下代码为了方便理解，略有删减*//* * 导航切换 */watch()&#123; translateX(value)&#123; //滚动条位置修改 this.scrollView.scrollLeft = Math.abs(value) &#125;&#125;,methods:&#123; center(index)&#123; //当前选中项 const activeItem = this.$refs.navitem[index] //选中项距离左边的距离和宽度 const &#123;offsetLeft,offsetWidth&#125; = activeItem //导航条可见的宽度 const touchWidth = this.stickyNav.offsetWidth //可滚动宽度 = 整个滚动宽度 - 导航条可见的宽度 const scrollWidth = this.scrollView.scrollWidth - touchWidth //导航条中点 const half = (touchWidth - offsetWidth) / 2 //需要滚动的长度 let scrollLeft = half - offsetLeft //到达最左边 scrollLeft &gt; 0 &amp;&amp; (scrollLeft = 0); //到达最右边 scrollLeft &lt; -scrollWidth &amp;&amp; (scrollLeft = -scrollWidth) this.translateX = scrollLeft &#125;&#125; 导航缓动实现了导航居中后我们再给他加一个缓动的效果，上面已经通过监听滚动的值去修改滚动条scrollLeft改变位置，由于watch可以监听值的变化，我们可以取到初始值和结束值，所以我们只需给数字变化添加一个缓动的过程，这里使用了一个插件tweenjs来实现这个功能。1234567891011121314151617181920212223242526272829import tween from '@tweenjs/tween.js\"watch:&#123; translateX(star, end) &#123; this.tween(star,end) &#125;&#125;methods:&#123; tween(start,end)&#123; new TWEEN.Tween(&#123; number: start &#125;) .to(&#123; number: end &#125;, 100) .onUpdate(tween =&gt; &#123; //改变滚动位置 this.scrollView.scrollLeft = -tween.number; &#125;) .start(); function animate()&#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; animate() &#125;&#125; 滚动过程中的隐藏和显示实现这个功能我们需要知道用户当前的操作是上划还是下划，同样借助于vue中的watch功能，我们监听当前屏幕滚动的距离scrollTop,可以得到一个当前值和过去值，将两个值对比，当前值大于过去值的时候，则表示用户手指是向上滑（屏幕往下滚动）的，反之向下，代码如下：12345678910111213141516171819202122232425262728293031/*以下代码为了方便理解，略有删减*/data()&#123; //控制导航是否显示隐藏的变量 scrollHide:false, //需要设置一个定时器，当用户一段时间没操作的时候，显示导航条 scrollTimer:false &#125;,watch:&#123; scrollTop(newValue, oldValue)&#123; const delay = 2000 //向下滚动 if(newValue &gt; oldvalue)&#123; //改变属性，控制隐藏显示 this.scrollHide = true //清除定时器 clearTimeout(this.scrollTimer) this.scrollTimer = null //向上 &#125;else&#123; this.scrollHide = fasle &#125; if(!this.scrollTimer)&#123; this.scrollTimer = setTimeout(()=&gt;&#123; this.scrollHide = fasle &#125;) &#125; &#125;&#125; 向下滚动隐藏的功能是实现了，但还有一个问题，就是当点击导航栏的时候页面也是向下滚的，这时候还会触发上面的函数，这个时候体验效果有点奇怪，所以还需要优化下，当用户的操作是点击屏幕的时候不去执行隐藏导航的功能 改进版1234567891011121314151617181920212223242526272829303132333435363738394041424344/*以下代码为了方便理解，略有删减*/data()&#123; //控制导航是否显示隐藏的变量 scrollHide:false, //需要设置一个定时器，当用户一段时间没操作的时候，显示导航条 scrollTimer:false, //是否点击事件 isClickScroll: false&#125;,methods:&#123; //点击时触发 change(index) &#123; this.isClickScroll = true; &#125;&#125;,watch:&#123; scrollTop(newValue, oldValue)&#123; if(this.isClickScroll)&#123; setTimeout(() =&gt; &#123; this.isClickScroll = false &#125;, 10); &#125; if (this.isClickScroll) return; const delay = 2000 //向下滚动 if(newValue &gt; oldvalue)&#123; //改变属性，控制隐藏显示 this.scrollHide = true; //清除定时器 clearTimeout(this.scrollTimer); this.scrollTimer = null; //向上 &#125;else&#123; this.scrollHide = fasle; &#125; if(!this.scrollTimer)&#123; this.scrollTimer = setTimeout(()=&gt;&#123; this.scrollHide = fasle; this.isClickScroll = false; &#125;) &#125; &#125;&#125; 遇到的一些问题京东APP沉浸式兼容问题沉浸式效果： 沉浸式就是去掉了首屏标题栏的一种沉浸式体验，，如果开启了沉浸式，那么首屏标题栏是一个透明的状态，整个页面的高度就会上移，然后当你往下滑动的时候标题栏会出现，这时候导航栏如果吸顶，那么就会被标题栏给挡住看不到了，解决方法就是需要增加导航栏距离顶部的高度，而且是动态修改的，因为在APP中获取标题栏的高度是一个异步的操作，原先组件中并没考虑需要动态修改高度的情况，所以需要点小修改，先看下一开始是怎么初始化组件的： 12345678&lt;StickyNav :options=\"options\"/&gt;options:&#123; disabled:false, stickyTop:0, //距离顶部 zIndex:1000, ...&#125; 我们是通过stickyTop属性来控制导航栏距离顶部的距离，但是如果异步去修改这个对象的值是没有任何变化的，因为vue中是无法检测到对象的修改， 1.通过watch的deep属性，设置为true可以监听options对象的修改,再重新复制到新对象12345678watch&#123; options:&#123; handler(value)&#123; assign(this.stickyOptions,value) &#125;, deep:true &#125;&#125; 2.或者把stickyTop单独作为一个prop属性传给组件，这样可以实时变化 低端机兼容性问题兼容性问题通常出现在一些很低端的手机上，比如android4.0,ios8、不过如果做到以下3点基本也没什么问题 1.ES6兼容通常我们webpack上已经配置了babel转换，但其实只是对语法的编译，比如你可以使用箭头函数等如果你使用了Promise、Object.assign、includes等全局方法其实都不能被转换的，最简单的方法可以全局引入polyfill 12npm install babel-polyfill --saveimport 'babel-polyfill' 或者你的项目中只是用了一两个方法，引入整个polyfill太浪费，也可以使用一些第三方库，如 lodash/includes 2.CSS自动 -webkit- 前缀还有就是样式不生效的问题，一般我们现在都是在webpack工程中配置autoprefixer去自动加前缀，不过要注意修改下package.json下的browserslist1234\"browserslist\": [ \"Android &gt;= 4.4\", \"iOS 8\" ] 3.尽量不要使用flex布局flex布局有某些很老的机型还是支持不是很好，用inline-block来代替 结束本文到这里就结束啦，组件vue-stivky-nav已经开源到npm上，欢迎使用和提问题,如果您对本文有什么问题也可以在底下留言讨论。","pubDate":"Thu, 23 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/23/mobile-top-nav/","category":"经验分享"},{"title":"618前端竞品分析研究（互动篇）","link":"https://aotu.io/notes/2020/07/21/618-what-taobao-do/","description":"智能化测试在互动中经常需要维护大量的状态，对这些状态进行测试验证成本较高，尤其是当有功能变动需要回归测试的时候。为了降低开发测试的成本，在这方面使用强化学习模拟用户行为，在两个方面提效： mock接口：将学习过程中的状态作为服务接口的测试数据； 回归测试：根据mock接口数据回溯到特定状态，Puppeteer根据强化学习触发前端操作，模拟真实用户行为； 什么是强化学习呢？ 强化学习是机器学习的一个领域，它强调如何基于环境行动，获取最大化的预期利益。强化学习非常适用于近几年比较流行的电商互动机制：做任务/做游戏 -&gt; 得到不同的奖励值 -&gt; 最终目标大奖，在这类型的互动游戏中，奖励是可预期的，用户的目标是使得自己的奖励最大化。这个过程可以抽象为马尔科夫决策模型：玩家（agent）通过不同的交互行为（action），改变游戏（environment）的状态（state），反馈给玩家不同的奖励 （reward）；这个过程不断循环迭代， 玩家的最终目标是奖励最大化。 接下来，我们使用比较简单的Q-learning，来实现类似的智能化测试目的。 Q-learning对于不同状态下，Q-learning的Q(s,a)表示在某一个时刻的s状态下，采取动作a可以得到的收益期望，算法的主要思想是将state和ation构建一张Q-table来存储Q值，根据Q值来选取能够获得最大收益的动作。Q值的公式计算如下： 其中，s表示state，a表示action，α为学习率，γ为衰减率，r表示action能带来的收益。 这个公式表示当前状态的Q值由“记忆中”的利益（max Q[s’,a]）和当前利益（r）结合形成。衰减率γ越高，“记忆中”的利益影响越大；学习率α越大，当前利益影响越大。Q-learning的目标是通过不断训练，最后得到一个能拿到最多奖励的最优动作序列。 在赛车游戏中，玩家的交互行为包含购买车厢、合成车厢、做任务获得金币（为了方便理解，此处简化为一个任务）；玩家从初始化状态开始，通过重复“action -&gt; 更新state”的过程，以下的伪代码简单的说明我们怎么得到一个尽量完美的Q表格： 1234567891011// action: [ 购买车厢，合成车厢，做任务获得金币 ]// state: 包含等级、拥有车厢等级、剩余金币表示初始化 Q = &#123;&#125;while Q未收敛： 初始化游戏状态state while 赛车没有达到50级： 使用策略π，获得动作a = π(S) 使用动作a，获得新的游戏状态state 更新Q，Q[s,a] ← (1-α)*Q[s,a] + α*(R(s,a) + γ* max Q[s',a]) 更新状态state 简单的demo地址：https://github.com/winniecjy/618taobao Puppeteer由上面Q-learning的训练过程，我们可以得到一系列的中间态接口作为mock数据，可以很快的回溯到特定状态进行测试，这一点在回归测试的时候十分有用。但是仅仅只是自动mock数据对效率提升还是有限，在618互动中，友商的互动团队结合Puppeteer对整个流程进行自动化测试。Puppeteer是chrome团队推出的一个工具引擎，提供了一系列的API控制Chrome，可以自动提交表单、键盘输入、拦截修改请求、保存UI快照等。 结合Puppeteer的一系列操作逻辑，部分是可以沉淀成为一个通用的测试环境的，比如： 不同用户类型，如登录、非登录、风险、会员等； 接口拦截mock逻辑； 页面快照留存； 页面性能数据留存； 其他常见的业务逻辑，如互动任务体系，跳转后等几秒后返回，加积分； … 弹窗规模化在互动中，弹窗一直是视觉表现的一个重要组成部分，对UI有比较强的定制需求。 友商的思路是将所有的逻辑尽可能的沉淀。对于电商场景来说，弹窗的业务逻辑是可穷举、可固化的，而互动场景之下，UI定制化需求很高，所以将UI层抽离， 仅对可复用的逻辑进行固化，以DSL + Runtime的机制动态下发。 结合这一套逻辑层模型，表达层/UI层也可以相应的结构化。根据项目 &gt; 场景 &gt; 图层的维度，静态配置和动态绑定相结合，搭配对应的配置平台就可以实现动态下发。 总结对于智能化测试，80%的流程其实成本是相对较低的，从测试用例的生成到puppeteer自动化测试，都是可以参考学习的，图像对比的部分需要较多训练，对于固化的功能可以进行探索，如果是新的模式性价比较低。 对于弹窗规模化，部门内部的做法是将弹窗沉淀成一个通用的组件，只包含通用的兼容逻辑，包括显示/隐藏、弹窗出现底层禁止滚动、多弹窗层级问题等。对于UI和其他业务逻辑，复用性较低，所以每次都是重写。这种做法尽可能地保持了组件的通用性，在会场线比较适用，因为会场线的弹窗一般不包含业务逻辑（如抽奖、PK等），但是对于互动线来说，复用的内容相较于弹窗的“重量”来说显得有些微不足道。 友商的沉淀思路前提在于上游接口的逻辑需要可复用，上游逻辑如果无法固定下来，前端的互动逻辑也较难固化。总体来说，友商在互动方面的沉淀思路大部分是从开发提效出发，主要供给内部使用；京东内部已有类似的互动提效方案终极目标是盈利，如京喜的社交魔方平台和最近正在成型的满天星平台，所以沉淀方式都是以成套的H5。 参考[1] 生产力再提速，618互动项目进化之路[2] 机器学习相关教程 - 莫烦[3] Puppeteer docs","pubDate":"Tue, 21 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/21/618-what-taobao-do/","category":"经验分享"},{"title":"Webpack原理浅析","link":"https://aotu.io/notes/2020/07/17/webpack-analize/","description":"背景Webpack 迭代到4.x版本后，其源码已经十分庞大，对各种开发场景进行了高度抽象，阅读成本也愈发昂贵。但是为了了解其内部的工作原理，让我们尝试从一个最简单的 webpack 配置入手，从工具设计者的角度开发一款低配版的 Webpack。","pubDate":"Fri, 17 Jul 2020 06:34:02 GMT","guid":"https://aotu.io/notes/2020/07/17/webpack-analize/","category":"Web开发"},{"title":"京喜前端自动化测试之路(小程序篇)","link":"https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/","description":"如果你已经阅读过 “京喜前端自动化测试之路（一）”，可跳过前言部分阅读。 前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景模拟异常导致演习效率较低，因此想通过开发自动化测试工具来提升演习效率，让容灾演习工作随时可以轻松开展。由于京喜 H5 和小程序场景差异比较大，自动化测试分 H5 和小程序两部分进行。前期已经分享过 H5 的自动化测试方案 —— 京喜前端自动化测试之路（一），本文则主要讲述小程序版的自动化测试方案。 综上所述，我们希望京喜小程序自动化测试工具可以提供以下功能： 访问目标页面，对页面进行截图； 模拟用户点击、滑动页面操作； 网络拦截、模拟异常情况（接口响应码 500、接口返回数据异常）； 操作缓存数据（模拟有无缓存的场景等）。 小程序自动化 SDK聊到小程序的自动化工具，微信官方为开发者提供了一套小程序自动化 SDK —— miniprogram-automator ， 我们不需要关注技术选型，可直接使用。 小程序自动化 SDK 为开发者提供了一套通过外部脚本操控小程序的方案，从而实现小程序自动化测试的目的。 如果你之前使用过 Selenium WebDriver 或者 Puppeteer，那你可以很容易快速上手。小程序自动化 SDK 与它们的工作原理是类似的，主要区别在于控制对象由浏览器换成了小程序。 特性 通过该 SDK，你可以做到以下事情： 控制小程序跳转到指定页面 获取小程序页面数据 获取小程序页面元素状态 触发小程序元素绑定事件 往 AppService 注入代码片段 调用 wx 对象上任意接口 … 示例123456789101112131415const automator = require('miniprogram-automator')automator .launch(&#123; cliPath: '/Applications/wechatwebdevtools.app/Contents/MacOS/cli', // 工具 cli 位置（绝对路径） projectPath: 'path/to/project', // 项目文件地址（绝对路径） &#125;) .then(async miniProgram =&gt; &#123; const page = await miniProgram.reLaunch('/pages/index/index') await page.waitFor(500) const element = await page.$('.banner') console.log(await element.attribute('class')) await element.tap() await miniProgram.close() &#125;) 综上所述，我们选择使用官方维护的 SDK —— miniprogram-automator 开发小程序的自动化测试工具，通过 SDK 提供的一系列 API ，实现访问目标页面、模拟异常场景、生成截图的过程自动化。最后再通过人工比对截图，判断页面降级处理是否符合预预期、用户体验是否友好。 实现方案原来的容灾演习过程： 小程序的通信方式改成 HTTPS ，通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降级处理符合预期。 现阶段的容灾演习自动化方案： 我们将容灾演习过程分为自动化流程和人工操作两部分。 自动化流程： 启动微信开发者工具（开发版）; 访问目标页面，模拟用户点击、滑动等行为； 模拟异常场景：拦截网络请求，修改接口返回数据（接口返回 500、异常数据等）； 生成截图。 人工操作： 自动化脚本执行完毕后，人工比对各个场景的截图，判断是否符合预期。 方案流程图： 开发实录快速创建测试用例为了提高测试脚本的可维护性、扩展性，我们将测试用例的信息都配置到 JSON 文件中，这样编写测试脚本的时候，我们只需关注测试流程的实现。 测试用例 JSON 数据配置包括公用数据（global）和私有数据： 公用数据（global）：各测试用例都需要用到的数据，如：模拟访问的目标页面地址、名字、描述、设备类型等。 私有数据： 各测试用例特定的数据，如测试模块信息、api 地址、测试场景、预期结果、截图名字等数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"global\": &#123; \"url\": \"/pages/index/index\", \"pageName\": \"index\", \"pageDesc\": \"首页\", \"device\": \"iPhone X\" &#125;, \"homePageApi\": &#123; \"id\": 1, \"module\": \"home_page_api\", \"moduleDesc\": \"首页主接口\", \"api\": \"https://xxx\", \"operation\": \"模拟响应码 500\", \"expectRules\": [ \"1. 有缓存数据，显示容灾兜底数据\", \"2. 请求容灾接口，显示容灾兜底数据\", \"3. 容灾接口异常，显示信异常息、刷新按钮\", \"4. 恢复网络，点击刷新按钮，显示正常数据\" ], \"screenshot\": [ &#123; \"name\": \"normal\", \"desc\": \"正常场景\" &#125;, &#123; \"name\": \"500_cache\", \"desc\": \"有缓存-主接口返回500\" &#125;, &#123; \"name\": \"500_no_cache\", \"desc\": \"无缓存-主接口返回500-容灾兜底数据\" &#125;, &#123; \"name\": \"500_no_cache_500_disaster\", \"desc\": \"无缓存-主接口返回500-容灾兜底接口返回500\" &#125;, &#123; \"name\": \"500_no_cache_recover\", \"desc\": \"无缓存-返回500-恢复网络\" &#125; ] &#125;, …&#125; 编写测试脚本我们以京喜首页主接口的测试用例为例子，通过模拟主接口返回 500 响应码的异常场景，验证主接口的异常处理机制是否完善、用户体验是否友好。 预期效果： 主接口异常，有缓存数据，显示缓存数据 主接口异常，无缓存数据，则请求容灾接口，显示容灾兜底数据 主接口、容灾接口异常，无缓存数据，显示信异常息、刷新按钮 恢复网络，点击刷新按钮，显示正常数据 测试流程： 场景实现： 根据测试流程以及配置的测试用例信息，编写测试脚本，模拟测试用例场景: 访问页面 123456const miniProgram = await automator.launch(&#123; cliPath: '/Applications/wechatwebdevtools.app/Contents/MacOS/cli', // 开发者工具命令行工具（绝对路径） projectPath: 'jx_project', // 项目地址（绝对路径）&#125;)await miniProgram.reLaunch('/pages/index/index') 生成截图 123await miniProgram.screenshot(&#123; path: 'jx_weapp_index_home_page_500.png'&#125;) 模拟异常数据 12345678910111213141516171819202122232425262728293031323334353637383940414243const getMockData = (url, mockType, mockValue) =&gt; &#123; const result = &#123; data: 'test', cookies: [], header: &#123;&#125;, statusCode: 200, &#125; switch (mockType) &#123; case 'data': result.data = getMockResponse(url, mockValue) // 修改返回数据 break case 'cookies': result.cookies = mockValue // 修改返回数据 break case 'header': result.header = mockValue // 修改返回响应头 break case 'statusCode': result.statusCode = mockValue // 修改返回响应头 break &#125; return &#123; rule: url, result &#125; &#125; // 修改本地存储数据 const mockValue = &#123; data: &#123; modules: [&#123; tpl:'3000', content: [] &#125;] &#125; &#125; const mockData = [ getMockData(api1, 'statusCode', 500), // 模拟接口返回 500 getMockData(api2, 'data', mockValue) // 模拟接口返回异常数据 ... ] 拦截接口请求，修改返回数据 123456789101112131415161718192021222324252627282930const interceptAPI = async (miniProgram, url, mockData) =&gt; &#123; try &#123; await miniProgram.mockWxMethod( 'request', function(obj, data) &#123; // 处理返回函数 for (let i = 0, len = data.length; i &lt; len; i++) &#123; const item = data[i] // 命中规则的返回 mockData if (obj.url.indexOf(item.rule) &gt; -1) &#123; return item.result &#125; &#125; // 没命中规则的真实访问后台 return new Promise(resolve =&gt; &#123; obj.success = res =&gt; resolve(res) obj.fail = res =&gt; resolve(res) / origin 指向原始方法 this.origin(obj) &#125;) &#125;, mockData, // 传入 mock 数据 ) &#125; catch (e) &#123; console.error(`拦截【$&#123;url&#125;】API报错`) console.error(e) &#125; &#125;await interceptAPI(interceptAPI, url, mockData) miniProgram.mockWxMethod：覆盖 wx 对象上指定方法的调用结果。利用该 API，可以覆盖 wx.request API，拦截网络请求，修改返回数据。 目前是本地存储一份接口返回的 JSON 数据，通过修改本地的 JSON 数据生成 mockData。若需要修改接口实时返回的数据，可在 obj.success 中获取实时数据并修改。 清除缓存 123456try &#123; await miniProgram.callWxMethod('clearStorage')&#125; catch (e) &#123; await console.log(`清除缓存报错: `) await console.log(e)&#125; 点击刷新按钮 123const page = await miniProgram.currentPage()const $refreshBtn = await page.$('.page-error__refresh-btn') // 同 WXSS，仅支持部分 CSS 选择器await $refreshBtn.tap() 取消拦截，恢复网络 12345678910const cancelInterceptAPI = async (miniProgram) =&gt; &#123; try &#123; await miniProgram.restoreWxMethod('request') // 重置 wx.request ，消除 mockWxMethod 调用的影响。 &#125; catch (e) &#123; console.error(`取消拦截【$&#123;url&#125;】API报错`) console.error(e) &#125;&#125;await cancelInterceptAPI(miniProgram) 启动自动化测试由于第一阶段的测试工具尚未平台化，先通过在终端输入命令行，运行脚本的方式，启动自动化测试。 在项目的 package.json 文件中，使用 scripts 字段定义脚本命令： 123\"scripts\": &#123; \"start\": \"node pages/index/index.js\" &#125;, 运行环境： 安装 Node.js 并且版本大于 8.0 基础库版本为 2.7.3 及以上 开发者工具版本为 1.02.1907232 及以上 运行： 在终端切入到项目根目录路径，输入以下命令行，就可以启动测试工具，运行测试脚本。 1$ npm run start 测试结果人工比对截图结果： 运行脚本示例： 使用 SDK，你必须知道 Shadow DOM当我们想控制小程序页面时，需获取页面实例 page，利用 page 提供的方法控制页面内的元素。 比如，当我们想点击页面中搜索框时，我们一般会这么做：123const page = await miniProgram.currentPage()const $searchBar = await page.$('search-bar')await $searchBar.tap() 但这样真的可行吗？答案是： 试试就知道了。 运行这段测试脚本后生成的截图： 我们得到的结果是：根本没有触发点击事件。 Shadow DOM： 它是 HTML 的一个规范，它允许在文档( document )渲染时插入一颗DOM元素子树，但是这个子树不在主 DOM 树中。 它允许浏览器开发者封装自己的 HTML 标签、css 样式和特定的 javascript 代码、同时开发人员也可以创建类似 &lt;input&gt;、&lt;video&gt;、&lt;audio&gt; 等、这样的自定义的一级标签。创建这些标签内容相关的 API，可以被叫做 Web Component。 Shadow DOM 的关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。 Shadow host: 一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。它是 Shadow DOM 的一个宿主元素。比如：&lt;input /&gt;、&lt;audio&gt;、&lt;video&gt; 标签，就是 Shadow DOM 的宿主元素。 Shadow tree: Shadow DOM 内部的 DOM 树。 Shadow root: Shadow DOM 的根节点。通过 createShadowRoot 返回的文档片段被称为 shadow-root , 它和它的后代元素，都会对用户隐藏。 回到我们刚刚的问题： 由于小程序使用了 Shadow DOM，因此我们不能直接通过 page 实例获取到搜索框真实 DOM。我们看到的页面中渲染的搜索框，实际上是一个 Shadow DOM。因此，我们必须先获取到搜索框 Shadow DOM 的宿主元素，并通过宿主元素获取到搜索框真实的 DOM，最后触发真实 DOM 的点击事件。 1234const page = await miniProgram.currentPage()const $searchBarShadow = await page.$('search-bar')const $searchBar = await $searchBarShadow.$('.search-bar')const &#123; height &#125; = await $searchBar.size() 运行这段测试脚本后生成的截图： 从截图可以看到，触发了搜索框的点击事件。 更多测试场景实现1. 下拉刷新12345678const pullDownRefresh = async (miniProgram) =&gt; &#123; try &#123; await miniProgram.callWxMethod('startPullDownRefresh') &#125; catch (e) &#123; console.error('下拉刷新操作失败') console.error(e) &#125;&#125; 2. 滚动到指定 DOM 12345const page = await miniProgram.currentPage() // 获取页面实例const $recommendTabShadow = await page.$('recommend-tab') // 获取Shadow DOMconst $recommendTab = await $recommendTabShadow.$('.recommend') // 获取真实 DOMconst &#123; top &#125; = await $recommendTab.offset() // 获取DOM 定位await miniProgram.pageScrollTo(top) // 滚动到指定DOM 3. 事件 日志打印； 监听页面崩溃事件 12345678910// 日志打印时触发miniProgram.on('console', msg =&gt; &#123; console.log(msg.type, msg.args) &#125;)&#125;)// 页面 JS 出错时触发page.on('error', (e) =&gt; &#123; console.log(e)&#125;) 结语第一阶段的小程序自动化测试之路告一段落。和 H5 自动化测试一样，容灾演习已实现了半自动化，可通过在终端运行测试脚本，模拟异常场景自动生成截图，再配合人工比对截图操作，判断演习结果是否符合预期。目前已投入到每个月的容灾演习中使用。 由于 H5 和小程序的差异比较大，第一阶段的自动化测试分两端进行，测试脚本语法也是截然不同，需要同时维护两套测试工具。为了降低维护成本，提升测试脚本的开发效率，我们正在研发第二阶段的自动化测试工具，一套代码支持两端测试，目前已经进入内测阶段。更多彩蛋，敬请期待第二阶段自动化测试工具——多端自动化测试 SDK 。","pubDate":"Mon, 13 Jul 2020 09:58:08 GMT","guid":"https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/","category":"小程序"},{"title":"Taro 3 正式版发布：开放式跨端跨框架解决方案","link":"https://aotu.io/notes/2020/06/30/taro-3-0-0/","description":"Taro 3 正式版发布：开放式跨端跨框架解决方案从 Taro 第一个版本发布到现在，Taro 已经接受了来自于开源社区两年多的考验。今天我们很高兴地在党的生日发布 Taro 3（Taro Next）正式版，希望 Taro 未来的更多两年能像一名共产主义战士一样经受住更多的考验。以下是 Taro 3 的一些新增特性：","pubDate":"Tue, 30 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/30/taro-3-0-0/","category":"小程序"},{"title":"手把手教你写个小程序定时器管理库","link":"https://aotu.io/notes/2020/06/22/timer-miniprogram/","description":"背景凹凸曼是个小程序开发者，他要在小程序实现秒杀倒计时。于是他不假思索，写了以下代码： 123456789Page(&#123; init: function () &#123; clearInterval(this.timer) this.timer = setInterval(() =&gt; &#123; // 倒计时计算逻辑 console.log('setInterval') &#125;) &#125;,&#125;) 可是，凹凸曼发现页面隐藏在后台时，定时器还在不断运行。于是凹凸曼优化了一下，在页面展示的时候运行，隐藏的时候就暂停。 1234567891011121314151617181920Page(&#123; onShow: function () &#123; if (this.timer) &#123; this.timer = setInterval(() =&gt; &#123; // 倒计时计算逻辑 console.log('setInterval') &#125;) &#125; &#125;, onHide: function () &#123; clearInterval(this.timer) &#125;, init: function () &#123; clearInterval(this.timer) this.timer = setInterval(() =&gt; &#123; // 倒计时计算逻辑 console.log('setInterval') &#125;) &#125;,&#125;) 问题看起来已经解决了，就在凹凸曼开心地搓搓小手暗暗欢喜时，突然发现小程序页面销毁时是不一定会调用 onHide 函数的，这样定时器不就没法清理了？那可是会造成内存泄漏的。凹凸曼想了想，其实问题不难解决，在页面 onUnload 的时候也清理一遍定时器就可以了。 123456Page(&#123; ... onUnload: function () &#123; clearInterval(this.timer) &#125;,&#125;) 这下问题都解决了，但我们可以发现，在小程序使用定时器需要很谨慎，一不小心就会造成内存泄漏。后台的定时器积累得越多，小程序就越卡，耗电量也越大，最终导致程序卡死甚至崩溃。特别是团队开发的项目，很难确保每个成员都正确清理了定时器。因此，写一个定时器管理库来管理定时器的生命周期，将大有裨益。 思路整理首先，我们先设计定时器的 API 规范，肯定是越接近原生 API 越好，这样开发者可以无痛替换。 1234function $setTimeout(fn, timeout, ...arg) &#123;&#125;function $setInterval(fn, timeout, ...arg) &#123;&#125;function $clearTimeout(id) &#123;&#125;function $clearInterval(id) &#123;&#125; 接下来我们主要解决以下两个问题 如何实现定时器暂停和恢复 如何让开发者无须在生命周期函数处理定时器 如何实现定时器暂停和恢复思路如下: 将定时器函数参数保存，恢复定时器时重新创建 由于重新创建定时器，定时器 ID 会不同，因此需要自定义全局唯一 ID 来标识定时器 隐藏时记录定时器剩余倒计时时间，恢复时使用剩余时间重新创建定时器 首先我们需要定义一个 Timer 类，Timer 对象会存储定时器函数参数，代码如下 123456789101112131415161718192021222324class Timer &#123; static count = 0 /** * 构造函数 * @param &#123;Boolean&#125; isInterval 是否是 setInterval * @param &#123;Function&#125; fn 回调函数 * @param &#123;Number&#125; timeout 定时器执行时间间隔 * @param &#123;...any&#125; arg 定时器其他参数 */ constructor (isInterval = false, fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; this.id = ++Timer.count // 定时器递增 id this.fn = fn this.timeout = timeout this.restTime = timeout // 定时器剩余计时时间 this.isInterval = isInterval this.arg = arg &#125; &#125; // 创建定时器 function $setTimeout(fn, timeout, ...arg) &#123; const timer = new Timer(false, fn, timeout, arg) return timer.id &#125; 接下来，我们来实现定时器的暂停和恢复，实现思路如下： 启动定时器，调用原生 API 创建定时器并记录下开始计时时间戳。 暂停定时器，清除定时器并计算该周期计时剩余时间。 恢复定时器，重新记录开始计时时间戳，并使用剩余时间创建定时器。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Timer &#123; constructor (isInterval = false, fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; this.id = ++Timer.count // 定时器递增 id this.fn = fn this.timeout = timeout this.restTime = timeout // 定时器剩余计时时间 this.isInterval = isInterval this.arg = arg &#125; /** * 启动或恢复定时器 */ start() &#123; this.startTime = +new Date() if (this.isInterval) &#123; /* setInterval */ const cb = (...arg) =&gt; &#123; this.fn(...arg) /* timerId 为空表示被 clearInterval */ if (this.timerId) this.timerId = setTimeout(cb, this.timeout, ...this.arg) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) return &#125; /* setTimeout */ const cb = (...arg) =&gt; &#123; this.fn(...arg) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) &#125; /* 暂停定时器 */ suspend () &#123; if (this.timeout &gt; 0) &#123; const now = +new Date() const nextRestTime = this.restTime - (now - this.startTime) const intervalRestTime = nextRestTime &gt;=0 ? nextRestTime : this.timeout - (Math.abs(nextRestTime) % this.timeout) this.restTime = this.isInterval ? intervalRestTime : nextRestTime &#125; clearTimeout(this.timerId) &#125;&#125; 其中，有几个关键点需要提示一下： 恢复定时器时，实际上我们是重新创建了一个定时器，如果直接用 setTimeout 返回的 ID 返回给开发者，开发者要 clearTimeout，这时候是清除不了的。因此需要在创建 Timer 对象时内部定义一个全局唯一 ID this.id = ++Timer.count，将该 ID 返回给 开发者。开发者 clearTimeout 时，我们再根据该 ID 去查找真实的定时器 ID (this.timerId)。 计时剩余时间，timeout = 0 时不必计算；timeout &gt; 0 时，需要区分是 setInterval 还是 setTimeout，setInterval 因为有周期循环，因此需要对时间间隔进行取余。 setInterval 通过在回调函数末尾调用 setTimeout 实现，清除定时器时，要在定时器增加一个标示位（this.timeId = “”）表示被清除，防止死循环。 我们通过实现 Timer 类完成了定时器的暂停和恢复功能，接下来我们需要将定时器的暂停和恢复功能跟组件或页面的生命周期结合起来，最好是抽离成公共可复用的代码，让开发者无须在生命周期函数处理定时器。翻阅小程序官方文档，发现 Behavior 是个不错的选择。 Behaviorbehaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。每个 behavior 可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。每个组件可以引用多个 behavior，behavior 也可以引用其他 behavior 。 123456789101112131415161718192021222324// behavior.js 定义behaviorconst TimerBehavior = Behavior(&#123; pageLifetimes: &#123; show () &#123; console.log('show') &#125;, hide () &#123; console.log('hide') &#125; &#125;, created: function () &#123; console.log('created')&#125;, detached: function() &#123; console.log('detached') &#125;&#125;)export &#123; TimerBehavior &#125;// component.js 使用 behaviorimport &#123; TimerBehavior &#125; from '../behavior.js'Component(&#123; behaviors: [TimerBehavior], created: function () &#123; console.log('[my-component] created') &#125;, attached: function () &#123; console.log('[my-component] attached') &#125;&#125;) 如上面的例子，组件使用 TimerBehavior 后，组件初始化过程中，会依次调用 TimerBehavior.created() =&gt; Component.created() =&gt; TimerBehavior.show()。因此，我们只需要在 TimerBehavior 生命周期内调用 Timer 对应的方法，并开放定时器的创建销毁 API 给开发者即可。思路如下： 组件或页面创建时，新建 Map 对象来存储该组件或页面的定时器。 创建定时器时，将 Timer 对象保存在 Map 中。 定时器运行结束或清除定时器时，将 Timer 对象从 Map 移除，避免内存泄漏。 页面隐藏时将 Map 中的定时器暂停，页面重新展示时恢复 Map 中的定时器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const TimerBehavior = Behavior(&#123; created: function () &#123; this.$store = new Map() this.$isActive = true &#125;, detached: function() &#123; this.$store.forEach(timer =&gt; timer.suspend()) this.$isActive = false &#125;, pageLifetimes: &#123; show () &#123; if (this.$isActive) return this.$isActive = true this.$store.forEach(timer =&gt; timer.start(this.$store)) &#125;, hide () &#123; this.$store.forEach(timer =&gt; timer.suspend()) this.$isActive = false &#125; &#125;, methods: &#123; $setTimeout (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(false, fn, timeout, ...arg) this.$store.set(timer.id, timer) this.$isActive &amp;&amp; timer.start(this.$store) return timer.id &#125;, $setInterval (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(true, fn, timeout, ...arg) this.$store.set(timer.id, timer) this.$isActive &amp;&amp; timer.start(this.$store) return timer.id &#125;, $clearInterval (id) &#123; const timer = this.$store.get(id) if (!timer) return clearTimeout(timer.timerId) timer.timerId = '' this.$store.delete(id) &#125;, $clearTimeout (id) &#123; const timer = this.$store.get(id) if (!timer) return clearTimeout(timer.timerId) timer.timerId = '' this.$store.delete(id) &#125;, &#125;&#125;) 上面的代码有许多冗余的地方，我们可以再优化一下，单独定义一个 TimerStore 类来管理组件或页面定时器的添加、删除、恢复、暂停功能。 1234567891011121314151617181920212223242526272829303132333435class TimerStore &#123; constructor() &#123; this.store = new Map() this.isActive = true &#125; addTimer(timer) &#123; this.store.set(timer.id, timer) this.isActive &amp;&amp; timer.start(this.store) return timer.id &#125; show() &#123; /* 没有隐藏，不需要恢复定时器 */ if (this.isActive) return this.isActive = true this.store.forEach(timer =&gt; timer.start(this.store)) &#125; hide() &#123; this.store.forEach(timer =&gt; timer.suspend()) this.isActive = false &#125; clear(id) &#123; const timer = this.store.get(id) if (!timer) return clearTimeout(timer.timerId) timer.timerId = '' this.store.delete(id) &#125;&#125; 然后再简化一遍 TimerBehavior 1234567891011121314151617181920212223242526const TimerBehavior = Behavior(&#123; created: function () &#123; this.$timerStore = new TimerStore() &#125;, detached: function() &#123; this.$timerStore.hide() &#125;, pageLifetimes: &#123; show () &#123; this.$timerStore.show() &#125;, hide () &#123; this.$timerStore.hide() &#125; &#125;, methods: &#123; $setTimeout (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(false, fn, timeout, ...arg) return this.$timerStore.addTimer(timer) &#125;, $setInterval (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(true, fn, timeout, ...arg) return this.$timerStore.addTimer(timer) &#125;, $clearInterval (id) &#123; this.$timerStore.clear(id) &#125;, $clearTimeout (id) &#123; this.$timerStore.clear(id) &#125;, &#125;&#125;) 此外，setTimeout 创建的定时器运行结束后，为了避免内存泄漏，我们需要将定时器从 Map 中移除。稍微修改下 Timer 的 start 函数，如下： 123456789101112131415161718192021222324class Timer &#123; // 省略若干代码 start(timerStore) &#123; this.startTime = +new Date() if (this.isInterval) &#123; /* setInterval */ const cb = (...arg) =&gt; &#123; this.fn(...arg) /* timerId 为空表示被 clearInterval */ if (this.timerId) this.timerId = setTimeout(cb, this.timeout, ...this.arg) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) return &#125; /* setTimeout */ const cb = (...arg) =&gt; &#123; this.fn(...arg) /* 运行结束，移除定时器，避免内存泄漏 */ timerStore.delete(this.id) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) &#125;&#125; 愉快地使用从此，把清除定时器的工作交给 TimerBehavior 管理，再也不用担心小程序越来越卡。 123456789101112131415161718192021222324252627import &#123; TimerBehavior &#125; from '../behavior.js'// 在页面中使用Page(&#123; behaviors: [TimerBehavior], onReady() &#123; this.$setTimeout(() =&gt; &#123; console.log('setTimeout') &#125;) this.$setInterval(() =&gt; &#123; console.log('setTimeout') &#125;) &#125;&#125;)// 在组件中使用Components(&#123; behaviors: [TimerBehavior], ready() &#123; this.$setTimeout(() =&gt; &#123; console.log('setTimeout') &#125;) this.$setInterval(() =&gt; &#123; console.log('setTimeout') &#125;) &#125;&#125;) npm 包支持为了让开发者更好地使用小程序定时器管理库，我们整理了代码并发布了 npm 包供开发者使用，开发者可以通过 npm install --save timer-miniprogram 安装小程序定时器管理库，文档及完整代码详看 https://github.com/o2team/timer-miniprogram eslint 配置为了让团队更好地遵守定时器使用规范，我们还可以配置 eslint 增加代码提示，配置如下： 123456789101112131415161718// .eslintrc.jsmodule.exports = &#123; 'rules': &#123; 'no-restricted-globals': ['error', &#123; 'name': 'setTimeout', 'message': 'Please use TimerBehavior and this.$setTimeout instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;, &#123; 'name': 'setInterval', 'message': 'Please use TimerBehavior and this.$setInterval instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;, &#123; 'name': 'clearInterval', 'message': 'Please use TimerBehavior and this.$clearInterval instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;, &#123; 'name': 'clearTimout', 'message': 'Please use TimerBehavior and this.$clearTimout instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;] &#125;&#125; 总结千里之堤，溃于蚁穴。 管理不当的定时器，将一点点榨干小程序的内存和性能，最终让程序崩溃。 重视定时器管理，远离定时器泄露。 参考小程序开发者文档","pubDate":"Mon, 22 Jun 2020 04:00:00 GMT","guid":"https://aotu.io/notes/2020/06/22/timer-miniprogram/","category":"Web开发"},{"title":"图形处理：给 Canvas 文本填充线性渐变","link":"https://aotu.io/notes/2020/06/22/linearGradient/","description":"在 Canvas 中对文本填充水平或垂直的线性渐变可以轻易实现，而带角度的渐变就复杂很多；就好像下面这样，假设文本矩形宽为 W, 高为 H, 左上角坐标为 X, Y。 猜想与答案给出两个答案： 正确答案是图二，因为这样得出来的坐标生成的渐变最紧接文本矩形边界，它的运动轨迹如下动图： (图来源：Do you really know CSS linear-gradients） 渐变起点与终点坐标的计算所以，渐变的起点与终点坐标该怎么计算呢？答: 先求得起点与终点的长度（距离）。 根据长度与文本矩形的中心点坐标分别计算出起点与终点坐标。 线性渐变长度的计算 W3C 给出了一个公式（A 表示角度）： 1gradientLineLength = abs(W * sin(A)) + abs(H * cos(A)) 不过，该公式主要应用于 CSS 的线性渐变设置，即以 12 点钟方向为 0°，顺时针旋转。 而我们需要的是以 3 点钟方向为 0°，逆时针旋转，即公式为： 1234gradientLineLength = abs(W * cos(A)) + abs(H * sin(A))// 半长：halfGradientLineLength = (abs(W * cos(A)) + abs(H * sin(A))) / 2 那么这个公式是怎么来的呢？以下是笔者的求解： 由图可得以下方程组： 因此可推导出： 化简后为： 所以 c1 + c2 为： 由三角函数平方公式知：cos(A) * cos(A) = 1 - sin(A) * sin(A)， 代入 c1 + c2： 第一步化简后： 最后的结果就是： 因为 sin, cos 在函数周期内存在负值（见下面角度对应的三角函数周期图），所以线性渐变的长度需要取绝对值。 至此，我们知道了线性渐变长度，文本矩形的中心点坐标很好算，即： 12centerX = X + W / 2centerY = Y + H / 2 所以，起点与终点的坐标分别为： 12345startX = centerX - cos(A) * halfGradientLineLengthstartY = centerY + sin(A) * halfGradientLineLengthendX = centerX + cos(A) * halfGradientLineLengthendY = centerY - sin(A) * halfGradientLineLength 看看最终效果 经验注释进行三角函数计算时，应尽量避免先用 tan, 因为 tan 在其周期内存在无穷值，需要做特定的条件判断，而 sin, cos 没有此类问题，代码书写更为简洁清晰并且不会因疏忽产生错误，见下面三角函数与角度的对应关系周期图。 参阅：Do you really know CSS linear-gradients? MDN linear-gradient W3C - CSS Images Module Level 3 # linear-gradients","pubDate":"Mon, 22 Jun 2020 02:00:00 GMT","guid":"https://aotu.io/notes/2020/06/22/linearGradient/","category":"Web开发"},{"title":"向强大的SVG迈进","link":"https://aotu.io/notes/2020/06/09/strong-svg/","description":"SVG 即 Scalable Vector Graphics 可缩放矢量图形，使用XML格式定义图形。 一、SVG印象SVG 的应用十分广泛，得益于 SVG 强大的各种特性。 1.1、 矢量可利用 SVG 矢量的特点，描出深圳地铁的轮廓： 1.2、iconfontSVG 可依据一定的规则，转成 iconfont 使用： 1.3、 foreignObject利用 SVG 的 foreignObject 标签实现截图功能，原理：foreignObject 内部嵌入 HTML 元素： 12345&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;foreignObject width=\"120\" height=\"60\"&gt; &lt;p style=\"font-size:20px;margin:0;\"&gt;凹凸实验室 欢迎您&lt;/p&gt; &lt;/foreignObject&gt;&lt;/svg&gt; 截图实现流程： 首先声明一个基础的 svg 模版，这个模版需要一些基础的描述信息，最重要的，它要有 &lt;foreignObject&gt;&lt;/foreignObject&gt; 这对标签； 将要渲染的 DOM 模版模版嵌入 foreignObject 即可； 利用 Blob 构建 svg 对象； 利用 URL.createObjectURL(svg) 取出 URL。 1.4、SVG SMIL由于微信编辑器不允许嵌入 &lt;style&gt;&lt;script&gt;&lt;a&gt; 标签，利用SVG SMIL 可进行微信公众号极具创意的图文排版设计，包括动画与交互。但是也要注意，标签里不允许有id，否则会被过滤或替换掉。 点击 “凹凸实验室” 后，围绕 “凹凸实验室” 中心旋转 360度，点击0.5秒后 出现 https://aotu.io/ ，动画只运行一次。 下图为 GIF循环演示： 代码如下：12345678910111213141516171819&lt;svg width=\"360\" height=\"300\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;g&gt; &lt;!-- 点击后 运行transform旋转动画，restart=\"never\"表示只运行一次 --&gt; &lt;animateTransform attributeName=\"transform\" type=\"rotate\" begin=\"click\" dur=\"0.5s\" from=\"0 100 80\" to=\"360 100 80\" fill=\"freeze\" restart=\"never\" /&gt; &lt;g&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"20\" x=\"50\" y=\"80\"&gt; 凹凸实验室 &lt;/text&gt; &lt;/g&gt; &lt;g style=\"opacity: 0;\"&gt; &lt;!-- 同一个初始位置以及大致的宽高，触发点击事件 --&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"20\" x=\"50\" y=\"80\"&gt;https://aotu.io/&lt;/text&gt; &lt;!-- 点击后 运行transform移动动画，改变文本的位置 --&gt; &lt;animateTransform attributeName=\"transform\" type=\"translate\" begin=\"click\" dur=\"0.1s\" to=\"0 40\" fill=\"freeze\" restart=\"never\" /&gt; &lt;!-- 点击0.5秒后 运行opacity显示动画 --&gt; &lt;animate attributeName=\"opacity\" begin=\"click+0.5s\" from=\"0\" to=\"1\" dur=\"0.5s\" fill=\"freeze\" restart=\"never\" /&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt; 以上是鄙人对SVG的大致印象，最近的需求开发再次刷新了我的认知，那就是 SVG实现非比例缩放 以及 小程序不支持SVG标签的处理，下面容我来讲述一番。 二、SVG 实现非比例缩放我们熟知的 iconfont，可通过改变字体大小缩放，但是这是 比例缩放，那如何实现 SVG 的非比例缩放呢？如下图所示，如何将 一只兔子 非比例缩放？ 划重点：实现非比例缩放主要涉及三个知识点：viewport、viewBox和preserveAspectRatio，viewport 与viewBox 结合可实现缩放的功能，viewBox 与 preserveAspectRatio 结合可实现非比例的功能。 2.1、viewportviewport 表示SVG可见区域的大小。viewport 就像是我们的显示器屏幕大小，超出区域则隐藏，原点位于左上角，x 轴水平向右，y 轴垂直向下。 通过类似CSS的属性 width、height 指定视图大小： 1&lt;svg width=\"400\" height=\"200\"&gt;&lt;/svg&gt; 2.2、viewBoxviewBox值有4个数字：x, y, width, height 。其中 x：左上角横坐标，y：左上角纵坐标，width：宽度，height：高度。原点默认位于左上角，x 轴水平向右，y 轴垂直向下。 1&lt;svg width=\"400\" height=\"200\" viewBox=\"0 0 200 100\"&gt;&lt;/svg&gt; 显示器屏幕的画面，可以特写，可以全景，这就是 viewBox。viewBox 可以想象成截屏工具选中的那个框框，和 viewport 作用的结果就是 把框框中的截屏内容再次在 显示器 中全屏显示。 （图片来源：SVG 研究之路 (23) - 理解 viewport 與 viewbox） 2.3、preserveAspectRatio上图的红色框框和蓝色框框，恰好和显示器的比例相同，如果是下图的绿色框框，怎样在显示器屏幕中显示呢？ 2.3.1、 定义preserveAspectRatio 作用的对象是 viewBox，使用方法如下：12preserveAspectRatio=\"[defer] &lt;align&gt; [&lt;meetOrSlice&gt;]\"// 例如 preserveAspectRatio=\"xMidYMid meet\" 其中 defer 此时不是重点，暂且忽略，主要了解 align 和 meetOrSlice 的 用法： align：由两个名词组成，分别代表 viewbox 与 viewport 的 x 方向、y方向的对齐方式。 值 含义 xMin viewport 和 viewBox 左边对齐 xMid viewport 和 viewBox x轴中心对齐 xMax viewport 和 viewBox 右边对齐 YMin viewport 和 viewBox 上边缘对齐。注意Y是大写。 YMid viewport 和 viewBox y轴中心点对齐。注意Y是大写。 YMax viewport 和 viewBox 下边缘对齐。注意Y是大写。 meetOrSlice：表示如何维持高宽的比例，有三个值 meet、slice、none。 meet - 默认值，保持纵横比缩放 viewBox 适应 viewport，可能会有余留的空白。 slice - 保持纵横比同时比例小的方向放大填满 viewport，超出的部分被剪裁掉。 none - 扭曲纵横比以充分适应 viewport。 2.3.2、 例子例子1：preserveAspectRatio=&quot;xMidYMid meet&quot; 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐； 例子2：preserveAspectRatio=&quot;xMidYMin slice&quot; 表示 绿色框框 与 显示器的 x 方向 中心点 对齐，Y 方向 上边缘对齐，保持比例放大填满 显示屏 后超出部分隐藏； 例子3：preserveAspectRatio=&quot;xMidYMid slice&quot; 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐，保持比例放大填满显示屏 后超出部分隐藏； 例子4：preserveAspectRatio=&quot;none&quot; 不管三七二十一，随意缩放绿色框框，填满 显示屏即可；这就是非比例缩放的答案了。 三、小程序不支持svg标签怎么办微信小程序官方不支持 SVG 标签的，但是决定曲线救国，相当于自己实现了一个SVG标签：使用小程序内置的 Canvas 渲染器， 在 Cax 中实现 SVG 标准的子集，使用 JSX 或者 HTM（Hyperscript Tagged Markup） 描述 SVG 结构行为表现。 但是今天我想讲讲其他的。我们知道，小程序虽然不支持 SVG 标签，但是支持 svg 转成 base64 后作为 background-image 的 url，如 background-image: url(&quot;data:image/svg+xml.......) 。 但是我这边还有个需求，随时更改 SVG 每个路径的颜色，即 颜色可配置： 来回转 Base64 肯定是比较麻烦的，有没有更好的方式呢？直接贴答案：对于SVG图形，还有更好的实现方式，就是直接使用SVG XML格式代码，无需进行base64转换。 3.1、URL 编码直接使用 SVG XML 格式代码，首先要了解 Data URI的格式。划重点：base64非必选项，不指定的时候，后面的 &lt;data&gt; 将使用 URL编码。 3.1.1、入门 百分号编码(Percent-encoding), 也称作URL编码(URL encoding)，是特定上下文的统一资源定位符 (URL)的编码机制。 原理：ASCII 字符 = % + 两位 ASCII 码（十六进制）。例如，字符 a 对应的 ASCII 码为 0x61，那么 URL 编码后得到 %61 。 3.1.2、URL 编码压缩前言： Data URI 的格式中的 &lt;data&gt; 完全使用URL 编码也是可以的，如 encodeURIComponent(&#39;&lt;svg version=&quot;1.1&quot; viewBox= …&lt;/svg&gt;&#39;)。但是和转义前原始SVG相比，可读性差了很多，而且占用体积也变大了。如果深入了解URL 编码的话，&lt;data&gt; 没必要全部编码的。 正文： RFC3986文档规定，URL中只允许包含 未保留字符 以及 所有保留字符。 未保留字符：包含英文字母（a-zA-Z）、数字（0-9）、-_.~ 4个特殊字符。对于未保留字符，不需要百分号编码。 保留字符：具有特殊含义的字符 :/?#[]@ (分隔Url的协议、主机、路径等组件) 和 !$&amp;&#39;()*+,;= （用于在每个组件中起到分隔作用的，如&amp;符号用于分隔查询多个键值对）。 受限字符或不安全字符：直接放在Url中的时候，可能会引起解析程序的歧义，因此这部分需要百分号编码，如%、空格、双引号&quot;、尖号 &lt;&gt;等等。 综上所述，只需要对 受限字符或不安全字符 进行编码即可。 JS 处理比较简单，利用 replace 将 需要编码的字符 替换掉 即可，基本替换 以下的符号 就够用了： 1234567891011121314svgToUrl (svgData) &#123; encoded = encoded .replace(/&lt;!--(.*)--&gt;/g, '') // 亲测必须去掉注释 .replace(/[\\r\\n]/g, ' ') // 亲测最好去掉换行 .replace(/\"/g, `'`) // 单引号是保留字符，双引号改成单引号减少编码 .replace(/%/g, '%25') .replace(/&amp;/g, '%26') .replace(/#/g, '%23') .replace(/&#123;/g, '%7B') .replace(/&#125;/g, '%7D') .replace(/&lt;/g, '%3C') .replace(/&gt;/g, '%3E') return `data:image/svg+xml,$&#123;encoded&#125;` &#125; 如果使用在 CSS 中，可利用 SASS版本3.3以上 的 三个API 对 SVG字符串做替换处理。 str_insert(string, insert, index)： 从 $string 第 $index 插入字符 $insert； str_index(string, substring): 返回 $substring 在 $string 中第一个位置； str_slice(string, start_at, end_at = nil): 返回从字符 $string 中第 $start_at 开始到 $end_at 结束的一个新字符串。 前人已有总结，可前往 https://github.com/leeenx/sass-svg/blob/master/sass-encodeuri.scss 查看完整代码。 3.2、SVG 压缩 一般从 Sketch 导出 SVG ，冗余代码比较多，有条件的话建议使用 SVGO 压缩SVG的原本体积，比如清除换行、重复空格；删除文档声明；删除注释；删除desc描述等等。 四、总结SVG强大的地方在于，出其不意，炫酷，与众不同。 无论是微信公众号花式排版，foreignObject 标签实现截图，实现非比例缩放，或者 背景图直接使用 SVG XML 格式代码，还是上文没有提及的路径动画、描边动画、图形裁剪、滤镜等等，都可以玩出新的花样。 SVG 一个属性可成就一篇文章，学习 SVG 可以说是在挑战自己，欢迎加入 SVG 的学习队列。 五、参考内容 · 推荐阅读三看 SVG Web 动效URL编码的奥秘学习了，CSS中内联SVG图片有比Base64更好的形式超级强大的SVG SMIL animation动画详解详细教你微信公众号正文页SVG交互开发SVG 简介与截图等应用","pubDate":"Tue, 09 Jun 2020 06:00:00 GMT","guid":"https://aotu.io/notes/2020/06/09/strong-svg/","category":"Web开发 移动开发"},{"title":"前端也要懂物理 —— 惯性滚动篇","link":"https://aotu.io/notes/2020/06/08/momentum-scrolling/","description":"我们在平时编程开发时，除了需要关注技术实现、算法、代码效率等因素之外，更要把所学到的学科知识（如物理学、理论数学等等）灵活应用，毕竟理论和实践相辅相成、密不可分，这无论是对于我们的方案选型、还是技术实践理解都有非常大的帮助。今天就让我们一起来回顾中学物理知识，并灵活运用到惯性滚动的动效实现当中。 惯性滚动（也叫 滚动回弹，momentum-based scrolling）最早是出现在 iOS 系统中，是指 当用户在终端上滑动页面然后把手指挪开，页面不会马上停下而是继续保持一定时间的滚动效果，并且滚动的速度和持续时间是与滑动手势的强烈程度成正比。抽象地理解，就像高速行驶的列车制动后依然会往前行驶一段距离才会最终停下。而且在 iOS 系统中，当页面滚动到顶/底部时，还有可能触发 “回弹” 的效果。这里录制了微信 APP 【账单】页面中的 iOS 原生时间选择器的惯性滚动效果： 熟悉 CSS 开发的同学或许会知道，在 Safari 浏览器中有这样一条 CSS 规则： 1-webkit-overflow-scrolling: touch; 当其样式值为 touch 时，浏览器会使用具有回弹效果的滚动, 即“当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果”。除此之外，在丰富多姿的 web 前端生态中，很多经典组件的交互都一定程度地沿用了惯性滚动的效果，譬如下面提到的几个流行 H5 组件库中的例子。 流行 UI 库效果为了方便对比，我们先来看看一个 H5 普通长列表在 iOS 系统下（开启了滚动回弹）的滚动表现： weui 的 picker 组件 明显可见，weui 选择器的惯性滚动效果非常弱，基本上手从屏幕上移开后滚动就很快停止了，体验较为不好。 vant 的 picker 组件 相比之下，vant 选择器的惯性滚动效果则明显清晰得多，但是由于触顶/底回弹时依然维持了普通滚动时的系数或持续时间，导致整体来说回弹的效果有点脱节。 应用物理学模型惯性 一词来源于物理学中的惯性定律（即 牛顿第一定律）：一切物体在没有受到力的作用的时候，运动状态不会发生改变，物体所拥有的这种性质就被称为惯性。可想而知，惯性滚动的本质就是物理学中的惯性现象，因此，我们可以恰当利用中学物理上的 滑块模型 来描述惯性滚动全过程。 为了方便描述，我们把浏览器惯性滚动效果中的滚动目标（如浏览器中的页面元素）模拟成滑块模型中的 滑块。而且分析得出，惯性滚动的全过程可以模拟为（人）使滑块滑动一定距离然后释放的过程，那么，全流程可以拆解为以下两个阶段： 第一阶段，滑动滑块使其从静止开始做加速运动； 在此阶段，滑块受到的 F拉 大于 F摩 使其从左到右匀加速前进。 需要注意的是，对于浏览器的惯性滚动来说，我们一般关注的是用户即将释放手指前的一小阶段，而非滚动的全流程（全流程意义不大），这一瞬间阶段可以简单模拟为滑块均衡受力做 匀加速运动。 第二阶段，释放滑块使其在只受摩擦力的作用下继续滑动，直至最终静止； 在此阶段，滑块只受到反向的摩擦力，会维持从左到右的运动方向减速前进然后停下。 基于滑块模型，我们需要找到适合的量化指标来建立惯性滚动的计算体系。结合模型和具体实现，我们需要关注 滚动距离、速度曲线 以及 滚动时长 这几个关键指标，下面会一一展开解析。 滚动距离对于滑动模型的第一阶段，滑块做匀加速运动，我们不妨设滑块的滑动距离为 s1，滑动的时间为 t1，结束时的临界点速度（末速度）为 v1 ，根据位移公式 可以得出速度关系 对于第二阶段，滑块受摩擦力 F拉 做匀减速运动，我们不妨设滑动距离为 s2，滑动的时间为 t2，滑动加速度为 a，另外初速度为 v1，末速度为 0m/s，结合位移公式和加速度公式 可以推算出滑动距离 s2 由于匀减速运动的加速度为负（即 a &lt; 0），不妨设一个加速度常量 A，使其满足 A = -2a 的关系，那么滑动距离 然而在浏览器实际应用时，v1 算平方会导致最终计算出的惯性滚动距离太大（即对滚动手势的强度感应过于灵敏），我们不妨把平方运算去掉： 所以，求惯性滚动的距离（即 s2）时，我们只需要记录用户滚动的 距离 s1 和 滚动时长 t1，并设置一个合适的 加速度常量 A 即可。 经大量测试得出，加速度常量 A 的合适值为 0.003。 另外，需要注意的是，对于真正的浏览器惯性滚动效果来说，这里讨论的滚动距离和时长是指能够作用于惯性滚动的范围内的距离和时长，而非用户滚动页面元素的全流程，详细的可以看【启停条件】这一节内容。 惯性滚动速度曲线针对惯性滚动阶段，也就是第二阶段中的匀减速运动，根据位移公式可以得到位移差和时间间距 T 的关系 不难得出，在同等时间间距条件下，相邻两段位移差会越来越小，换句话说就是惯性滚动的偏移量增加速度会越来越小。这与 CSS3 transition-timing-function 中的 ease-out 速度曲线非常吻合，ease-out （即 cubic-bezier(0, 0, .58, 1)）的贝塞尔曲线为 曲线图来自 在线绘制贝塞尔曲线网站。 其中，图表中的纵坐标是指 动画推进的进程，横坐标是指 时间，原点坐标为 (0, 0)，终点坐标为 (1, 1)，假设动画持续时间为 2 秒，(1, 1) 坐标点则代表动画启动后 2 秒时动画执行完毕（100%）。根据图表可以得出，时间越往后动画进程的推进速度越慢，符合匀减速运动的特性。 我们试试实践应用 ease-out 速度曲线： 很明显，这样的速度曲线过于线性平滑，减速效果不明显。我们参考 iOS 滚动回弹的效果重复测试，调整贝塞尔曲线的参数为 cubic-bezier(.17, .89, .45, 1)： 调整曲线后的效果理想很多： 回弹接下来模拟惯性滚动时触碰到容器边界触发回弹的情况。 我们基于滑块模型来模拟这样的场景：滑块左端与一根弹簧连接，弹簧另一端固定在墙体上，在滑块向右滑动的过程中，当滑块到达临界点（弹簧即将发生形变时）而速度还没有降到 0m/s 时，滑块会继续滑动并拉动弹簧使其发生形变，同时滑块会受到弹簧的反拉力作减速运动（动能转化为内能）；当滑块速度降为 0m/s 时，此时弹簧的形变量最大，由于弹性特质弹簧会恢复原状（内能转化成动能），并拉动滑块反向（左）运动。 类似地，回弹过程也可以分为下面两个阶段： 滑块拉动弹簧往右做变减速运动； 此阶段滑块受到摩擦力 F摩 和越来越大的弹簧拉力 F弹 共同作用，加速度越来越大，导致速度降为 0m/s 的时间会非常短。 弹簧恢复原状，拉动滑块向左做先变加速后变减速运动； 此阶段滑块受到的摩擦力 F摩 和越来越小的弹簧拉力 F弹 相互抵消，刚开始 F弹 &gt; F摩，滑块做加速度越来越小的变加速运动；随后 F弹 &lt; F摩，滑块做加速度越来越大的变减速运动，直至最终静止。这里为了方便实际计算，我们不妨假设一个理想状态：当滑块静止时弹簧刚好恢复形变。 回弹距离根据上面的模型分析，回弹的第一阶段做加速度越来越大的变减速直线运动，不妨设此阶段的初速度为 v0，末速度为 v1，那么可以与滑块位移建立关系： 其中 a 为加速度变量，这里暂不展开讨论。那么，根据物理学的弹性模型，第二阶段的回弹距离为 微积分都来了，简直没法计算…… 然而，我们可以根据运动模型适当简化 S回弹 值的计算。由于 回弹第二阶段的加速度 是大于 非回弹惯性滚动阶段的加速度（F弹 + F摩 &gt; F摩）的，不妨设非回弹惯性滚动阶段的总距离为 S滑，那么 因此，我们可以设置一个较为合理的常量 B，使其满足这样的等式： 经大量实践得出，常量 B 的合理值为 10。 回弹速度曲线触发回弹的整个惯性滚动轨迹可以拆分成三个运动阶段： 然而，如果要把阶段 a 和阶段 b 准确描绘成 CSS 动画是有很高的复杂度的： 阶段 b 中的变减速运动难以准确描绘； 这两个阶段虽运动方向相同但动画速度曲线不连贯，很容易造成用户体验断层； 为了简化流程，我们把阶段 a 和 b 合并成一个运动阶段，那么简化后的轨迹就变成： 鉴于在阶段 a 末端的反向加速度会越来越大，所以此阶段滑块的速度骤减同比非回弹惯性滚动更快，对应的贝塞尔曲线末端就会更陡。我们选择一条较为合理的曲线 cubic-bezier(.25, .46, .45, .94)： 对于阶段 b，滑块先变加速后变减速，与 ease-in-out 的曲线有点类似，实践尝试： 仔细观察，我们发现阶段 a 和阶段 b 的衔接不够流畅，这是由于 ease-in-out 曲线的前半段缓入导致的。所以，为了突出效果我们选择只描绘变减速运动的阶段 b 末段。贝塞尔曲线调整为 cubic-bezier(.165, .84, .44, 1) 实践效果： 由于 gif 转格式导致部分掉帧，示例效果看起来会有点卡顿，建议直接体验 demo CSS 动效时长我们对 iOS 的滚动回弹效果做多次测量，定义出体验良好的动效时长参数。在一次惯性滚动中，可能会出现下面两种情况，对应的动效时间也不一样： 没有触发回弹 惯性滚动的合理持续时间为 2500ms。 触发回弹 对于阶段 a，当 S回弹 大于某个关键阈值时定义为 强回弹，动效时长为 400ms；反之则定义为 弱回弹，动效时长为 800ms。 而对于阶段 b，反弹的持续时间为 500ms 较为合理。 启停条件前文中有提到，如果把用户滚动页面元素的整个过程都纳入计算范围是非常不合理的。不难想象，当用户以非常缓慢的速度使元素滚动比较大的距离，这种情况下元素动量非常小，理应不触发惯性滚动。因此，惯性滚动的触发是有条件的。 启动条件 惯性滚动的启动需要有足够的动量。我们可以简单地认为，当用户滚动的距离足够大（大于 15px）和持续时间足够短（小于 300ms）时，即可产生惯性滚动。换成编程语言就是，最后一次 touchmove 事件触发的时间和 touchend 事件触发的时间间隔小于 300ms，且两者产生的距离差大于 15px 时认为可启动惯性滚动。 暂停时机 当惯性滚动未结束（包括处于回弹过程），用户再次触碰滚动元素时，我们应该暂停元素的滚动。在实现原理上，我们需要通过 getComputedStyle 和 getPropertyValue 方法获取当前的 transform: matrix() 矩阵值，抽离出元素的水平 y 轴偏移量后重新调整 translate 的位置。 示例代码基于 vuejs 提供了部分关键代码，也可以直接访问 codepen demo 体验效果（完整代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;html&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;template id=\"tpl\"&gt; &lt;div ref=\"wrapper\" @touchstart.prevent=\"onStart\" @touchmove.prevent=\"onMove\" @touchend.prevent=\"onEnd\" @touchcancel.prevent=\"onEnd\" @transitionend=\"onTransitionEnd\"&gt; &lt;ul ref=\"scroller\" :style=\"scrollerStyle\"&gt; &lt;li v-for=\"item in list\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; new Vue(&#123; el: '#app', template: '#tpl', computed: &#123; list() &#123;&#125;, scrollerStyle() &#123; return &#123; 'transform': `translate3d(0, $&#123;this.offsetY&#125;px, 0)`, 'transition-duration': `$&#123;this.duration&#125;ms`, 'transition-timing-function': this.bezier, &#125;; &#125;, &#125;, data() &#123; return &#123; minY: 0, maxY: 0, wrapperHeight: 0, duration: 0, bezier: 'linear', pointY: 0, // touchStart 手势 y 坐标 startY: 0, // touchStart 元素 y 偏移值 offsetY: 0, // 元素实时 y 偏移值 startTime: 0, // 惯性滑动范围内的 startTime momentumStartY: 0, // 惯性滑动范围内的 startY momentumTimeThreshold: 300, // 惯性滑动的启动 时间阈值 momentumYThreshold: 15, // 惯性滑动的启动 距离阈值 isStarted: false, // start锁 &#125;; &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; this.wrapperHeight = this.$refs.wrapper.getBoundingClientRect().height; this.minY = this.wrapperHeight - this.$refs.scroller.getBoundingClientRect().height; &#125;); &#125;, methods: &#123; onStart(e) &#123; const point = e.touches ? e.touches[0] : e; this.isStarted = true; this.duration = 0; this.stop(); this.pointY = point.pageY; this.momentumStartY = this.startY = this.offsetY; this.startTime = new Date().getTime(); &#125;, onMove(e) &#123; if (!this.isStarted) return; const point = e.touches ? e.touches[0] : e; const deltaY = point.pageY - this.pointY; this.offsetY = Math.round(this.startY + deltaY); const now = new Date().getTime(); // 记录在触发惯性滑动条件下的偏移值和时间 if (now - this.startTime &gt; this.momentumTimeThreshold) &#123; this.momentumStartY = this.offsetY; this.startTime = now; &#125; &#125;, onEnd(e) &#123; if (!this.isStarted) return; this.isStarted = false; if (this.isNeedReset()) return; const absDeltaY = Math.abs(this.offsetY - this.momentumStartY); const duration = new Date().getTime() - this.startTime; // 启动惯性滑动 if (duration &lt; this.momentumTimeThreshold &amp;&amp; absDeltaY &gt; this.momentumYThreshold) &#123; const momentum = this.momentum(this.offsetY, this.momentumStartY, duration); this.offsetY = Math.round(momentum.destination); this.duration = momentum.duration; this.bezier = momentum.bezier; &#125; &#125;, onTransitionEnd() &#123; this.isNeedReset(); &#125;, momentum(current, start, duration) &#123; const durationMap = &#123; 'noBounce': 2500, 'weekBounce': 800, 'strongBounce': 400, &#125;; const bezierMap = &#123; 'noBounce': 'cubic-bezier(.17, .89, .45, 1)', 'weekBounce': 'cubic-bezier(.25, .46, .45, .94)', 'strongBounce': 'cubic-bezier(.25, .46, .45, .94)', &#125;; let type = 'noBounce'; // 惯性滑动加速度 const deceleration = 0.003; // 回弹阻力 const bounceRate = 10; // 强弱回弹的分割值 const bounceThreshold = 300; // 回弹的最大限度 const maxOverflowY = this.wrapperHeight / 6; let overflowY; const distance = current - start; const speed = 2 * Math.abs(distance) / duration; let destination = current + speed / deceleration * (distance &lt; 0 ? -1 : 1); if (destination &lt; this.minY) &#123; overflowY = this.minY - destination; type = overflowY &gt; bounceThreshold ? 'strongBounce' : 'weekBounce'; destination = Math.max(this.minY - maxOverflowY, this.minY - overflowY / bounceRate); &#125; else if (destination &gt; this.maxY) &#123; overflowY = destination - this.maxY; type = overflowY &gt; bounceThreshold ? 'strongBounce' : 'weekBounce'; destination = Math.min(this.maxY + maxOverflowY, this.maxY + overflowY / bounceRate); &#125; return &#123; destination, duration: durationMap[type], bezier: bezierMap[type], &#125;; &#125;, // 超出边界时需要重置位置 isNeedReset() &#123; let offsetY; if (this.offsetY &lt; this.minY) &#123; offsetY = this.minY; &#125; else if (this.offsetY &gt; this.maxY) &#123; offsetY = this.maxY; &#125; if (typeof offsetY !== 'undefined') &#123; this.offsetY = offsetY; this.duration = 500; this.bezier = 'cubic-bezier(.165, .84, .44, 1)'; return true; &#125; return false; &#125;, // 停止滚动 stop() &#123; const matrix = window.getComputedStyle(this.$refs.scroller).getPropertyValue('transform'); this.offsetY = Math.round(+matrix.split(')')[0].split(', ')[5]); &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 参考资料 weui-picker better-scroll","pubDate":"Mon, 08 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/08/momentum-scrolling/","category":"web 开发"},{"title":"从 SQL 到 MongoDB 之聚合篇","link":"https://aotu.io/notes/2020/06/07/sql-to-mongo-2/","description":"翻译原文：MongoDB 官方文档： SQL to Aggregation Mapping Chart 在上一篇翻译 从 SQL 到 MongoDB 之概念篇，我们详细讲解了 SQL 和 MongoDB 的一些概念的对应关系，方便大家入门和理解，这一篇属于进阶篇，主要讲解了 SQL 和 MongoDB 和 数据聚合 的对应关系。 聚合管道 （aggregation pipeline ） 让 MongoDB 提供与 SQL 中的许多常见数据聚合操作相对应的，原生的聚合功能。 下表概述了常见的 SQL 聚合术语、函数和概念以及相应的 MongoDB 聚合操作符（aggregation operators）： SQL 术语、函数和概念 MongoDB 聚合操作符 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum $sortByCount join $lookup SELECT INTO NEW_TABLE $out MERGE INTO TABLE $merge MongoDB 4.2 可用 有关所有聚合管道和表达式操作符的列表，请参见：Aggregation Pipeline Quick Reference。 另见：SQL to MongoDB Mapping Chart Examples下面提供了 SQL 聚合语句和相应的 MongoDB 语句，表中的例子假定以下条件： SQL 示例假定有两个表：orders 和 order_lineitem，然后通过 order_lineitem.order_id 和 orders.id 进行 join 操作。 MongoDB 示例假设其中一个集合（collection） orders 包含以下原型的文档（documents）： 12345678&#123; cust_id: \"abc123\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: 'A', price: 50, items: [ &#123; sku: \"xxx\", qty: 25, price: 1 &#125;, &#123; sku: \"yyy\", qty: 25, price: 1 &#125; ]&#125; COUNT vs count计算所有 orders 记录数量： SQL 示例 12SELECT COUNT(*) AS countFROM orders MongoDB 示例 12345678db.orders.aggregate( [ &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ) SUM vs $sum计算 orders 中 price 的总和： SQL 示例 12SELECT SUM(price) AS totalFROM orders MongoDB 示例 12345678db.orders.aggregate( [ &#123; $group: &#123; _id: null, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) GROUP BY vs $group对于每一个独特的 cust_id，计算 price 字段总和： SQL 示例 1234SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_id MongoDB 示例 12345678db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) ORDER BY vs $sort对于每一个独特的 cust_id，计算 price 字段总和，且结果按总和排序： SQL 示例 12345SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_idORDER BY total MongoDB 示例 123456789db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $sort: &#123; total: 1 &#125; &#125;] ) GROUP BY Multi对于每一个独特的 cust_id，按照 ord_date 进行分组，且不包含日期的时间部分，计算 price 字段总和。 SQL 示例 123456SELECT cust_id, ord_date, SUM(price) AS totalFROM ordersGROUP BY cust_id, ord_date MongoDB 示例 1234567891011121314db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: &#123; $dateToString: &#123; format: \"%Y-%m-%d\", date: \"$ord_date\" &#125;&#125; &#125;, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) HAVING vs $match对于 cust_id 如果有多个记录，就返回 cust_id 以及相应的记录数量： SQL 示例 123456SELECT cust_id, count(*)FROM ordersGROUP BY cust_idHAVING count(*) &gt; 1 MongoDB 示例 123456789db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", count: &#123; $sum: 1 &#125; &#125; &#125;, &#123; $match: &#123; count: &#123; $gt: 1 &#125; &#125; &#125;] ) WHERE vs $match对于每一个独特的 cust_id，且 status = ‘A’，计算 price 字段总和，只有在总和大于 250 的情况下，才可以返回。 SQL 示例 123456SELECT cust_id, SUM(price) as totalFROM ordersWHERE status = 'A'GROUP BY cust_idHAVING total &gt; 250 MongoDB 示例 12345678910db.orders.aggregate( [ &#123; $match: &#123; status: 'A' &#125; &#125;, &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $match: &#123; total: &#123; $gt: 250 &#125; &#125; &#125;] ) $unwind对于每一个独特的 cust_id，对相应的行的 item 项求和得到 qty： SQL 示例 123456SELECT cust_id, SUM(li.qty) as qtyFROM orders o, order_lineitem liWHERE li.order_id = o.idGROUP BY cust_id MongoDB 示例 123456789db.orders.aggregate( [ &#123; $unwind: \"$items\" &#125;, &#123; $group: &#123; _id: \"$cust_id\", qty: &#123; $sum: \"$items.qty\" &#125; &#125; &#125;] ) Multi aggregate将 cust_id, ord_date 分组并计算数量 ，不包括日期的时间部分。 1234567SELECT COUNT(*)FROM (SELECT cust_id, ord_date FROM orders GROUP BY cust_id, ord_date) as DerivedTable 12345678910111213141516171819db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: &#123; $dateToString: &#123; format: \"%Y-%m-%d\", date: \"$ord_date\" &#125;&#125; &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ) 另见 SQL to MongoDB Mapping Chart Aggregation Pipeline Quick Reference db.collection.aggregate()","pubDate":"Sun, 07 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/07/sql-to-mongo-2/","category":"全栈开发"},{"title":"从 SQL 到 MongoDB 之概念篇","link":"https://aotu.io/notes/2020/06/07/sql-to-mongo-1/","description":"翻译原文：MongoDB 官方文档：SQL to MongoDB Mapping Chart 前言很多开发者首次接触数据库（通常是在高校课堂）的概念，或者说接触第一个数据库，通常是 SQL 数据库，而现在，NoSQL 数据库越来越流行，很多原 SQL 数据的使用者难免有转向 NoSQL 的需求。而作为 NoSQL 数据库的代表，MongoDB 在社区越来越流行，生产环境的使用也日益广泛。 对于 SQL 转战 NoSQL的开发人员来说，最难的一步其实是将原有的 SQL 的概念和知识直接复用过来，最大化的减小学习的成本。 其实，这一步 MongoDB 官方已经为大家考虑到了，那就是在：MongoDB CRUD Operations &gt; MongoDB CRUD Operations &gt; SQL to MongoDB Mapping Chart，这篇文档非常好的总结了 SQL 对应 MongoDB 的术语和概念，还有可执行文件、SQL 语句/MongoDB 语句等， 可以说对于 SQL 数据库开发人员，如果理解了他们之间的对应关系，那么就一只脚就迈进了 MongoDB 的大门。 Terminology and Concepts下表介绍了各种 SQL 术语和概念以及相应的 MongoDB 术语和概念. SQL术语/概念 MongoDB 术语/概念 database database table collection row document 或 BSON document column field index index table joins （表联接） $lookup, embedded documents （嵌入式文档） primary key 指定任何唯一的列或者列组合作为主键 primary key 在 MongoDB 中, 主键自动设置为 _id 字段 aggregation (如：group by) aggregation pipeline （聚合管道）参考：SQL to Aggregation Mapping Chart SELECT INTO NEW_TABLE $out 参考： SQL to Aggregation Mapping Chart MERGE INTO TABLE $merge （从MongoDB 4.2开始可用） 参考：SQL to Aggregation Mapping Chart transactions transactions TIP 在许多情况下， 非规范化数据模型（嵌入式文档和数组） denormalized data model (embedded documents and arrays) 将继续是您数据和用例的最佳选择，而不是多文档事务. 也就是说，对于许多场景，对数据进行适当的建模将最大限度地减少对 多文档事务（multi-document transactions）的需求。 Executables下表显示了一些数据库可执行文件和相应的 MongoDB 可执行文件。 这张表并不是详尽无遗的。 MongoDB MySQL Oracle Informix DB2 Database Server mongod mysqld oracle IDS DB2 Server Database Client mongo mysql sqlplus DB-Access DB2 Client Examples下表显示了各种 SQL 语句和相应的 MongoDB 语句。 表中的例子假定以下条件: Sql 示例假设一个名为 people 的表。 MongoDB 的示例假定一个名为 people 的集合包含以下原型的文档： 123456&#123; _id: ObjectId(\"509a8fb2f3f4948bd2f983a0\"), user_id: \"abc123\", age: 55, status: 'A'&#125; Create and AlterCREATE TABLE SQL 模式语句： 12345678CREATE TABLE people ( id MEDIUMINT NOT NULL AUTO_INCREMENT, user_id Varchar(30), age Number, status char(1), PRIMARY KEY (id)) MongoDB 模式语句： 12345db.people.insertOne( &#123; user_id: \"abc123\", age: 55, status: \"A\" &#125; ) 在第一个 insertOne() 或 insertMany() 操作上隐式创建。 如果没有指定 _id 字段，则自动添加主键 _id。 但是，您也可以显式地创建一个集合： 1db.createCollection(\"people\") ALTER TABLE / ADD SQL模式语句： 12ALTER TABLE peopleADD join_date DATETIME MongoDB 模式语句： 1234db.people.updateMany( &#123; &#125;, &#123; $set: &#123; join_date: new Date() &#125; &#125;) 集合不描述或强制执行其文档的结构；也就是说，在集合级别上没有结构上的改变。 但是，在文档级别，updateMany() 操作可以使用 $set 操作符向现有文档添加字段。 ALTER TABLE / DROP COLUMN SQL模式语句： 12ALTER TABLE peopleDROP COLUMN join_date MongoDB 模式语句： 1234db.people.updateMany( &#123; &#125;, &#123; $unset: &#123; \"join_date\": \"\" &#125; &#125;) 集合不描述或强制执行其文档的结构；也就是说，在集合级别上没有结构上的改变。 但是，在文档级别，updateMany() 操作可以使用 $unset 操作符从文档中删除字段。 CREATE INDEX SQL 模式语句： 12CREATE INDEX idx_user_id_ascON people(user_id) MongoDB 模式语句： 1db.people.createIndex( &#123; user_id: 1 &#125; ) CREATE INDEX / Multi SQL模式语句： 123CREATE INDEX idx_user_id_asc_age_descON people(user_id, age DESC) MongoDB 模式语句： 1db.people.createIndex( &#123; user_id: 1, age: -1 &#125; ) DROP TABLE SQL模式语句： 1DROP TABLE people MongoDB 模式语句： 1db.people.drop() 更多有关使用的方法和操作符的详细信息，请参阅: db.collection.insertOne() db.collection.insertMany() db.createCollection() db.collection.updateMany() db.collection.createIndex() db.collection.drop() $set $unset 另见： Databases and Collections Documents Indexes Data Modeling Concepts Insert下表显示了与向表中插入记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 SQL INSERT 语句 123456INSERT INTO people(user_id, age, status)VALUES (\"bcd001\", 45, \"A\") Mongodb insertOne() 语句 123db.people.insertOne( &#123; user_id: \"bcd001\", age: 45, status: \"A\" &#125;) 有关更多信息，请参见 db.collection.insertOne()。 另见： Insert Documents db.collection.insertMany() Databases and Collections Documents Select下表显示了与从表中读取记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 NOTE： find() 方法总是包含返回文档中的 _id 字段，除非通过 projection 特别排除。 下面的一些 SQL 查询可能包含一个 _id 字段来反映这一点，即使该字段没有包含在相应的 find() 查询中。 SELECT … WHERE SQL 语句 1234SELECT user_id, statusFROM peopleWHERE status = \"A\" Mongodb 语句 1234db.people.find( &#123; status: \"A\" &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;) SELECT … AND SQL 语句 1234SELECT *FROM peopleWHERE age &gt; 25AND age &lt;= 50 Mongodb 语句 123db.people.find( &#123; age: &#123; $gt: 25, $lte: 50 &#125; &#125;) SELECT … OR SQL 语句 1234SELECT *FROM peopleWHERE status = \"A\"OR age = 50 Mongodb 语句 123db.people.find( &#123; $or: [ &#123; status: \"A\" &#125; , &#123; age: 50 &#125; ] &#125;) SELECT … LIKE SQL 语句 12FROM peopleWHERE user_id like \"%bc%\" Mongodb 语句 12345db.people.find( &#123; user_id: /bc/ &#125; )-or-db.people.find( &#123; user_id: &#123; $regex: /bc/ &#125; &#125; ) SELECT … OEDER BY SQL 语句 1234SELECT *FROM peopleWHERE status = \"A\"ORDER BY user_id ASC Mongodb 语句 1db.people.find( &#123; status: \"A\" &#125; ).sort( &#123; user_id: 1 &#125; ) SELECT … COUNT SQL 语句 12SELECT COUNT(user_id)FROM people Mongodb 语句 12345db.people.count( &#123; user_id: &#123; $exists: true &#125; &#125; )ordb.people.find( &#123; user_id: &#123; $exists: true &#125; &#125; ).count() SELECT DISTINCT SQL 语句 12SELECT DISTINCT(status)FROM people Mongodb 语句 123456db.people.aggregate( [ &#123; $group : &#123; _id : \"$status\" &#125; &#125; ] )或者，对于不同的不超过 [BSON 大小限制](https://docs.mongodb.com/manual/reference/limits/#limit-bson-document-size) 的值集db.people.distinct( \"status\" ) SELECT … LIMIT SKIP SQL 语句 1234SELECT *FROM peopleLIMIT 5SKIP 10 Mongodb 语句 1db.people.find().limit(5).skip(10) EXPLAIN SELECT SQL 语句 123EXPLAIN SELECT *FROM peopleWHERE status = \"A\" Mongodb 语句 1db.people.find( &#123; status: \"A\" &#125; ).explain() 有关所使用的方法的详细信息，请参阅： db.collection.find() db.collection.distinct() db.collection.findOne() limit() skip() explain() sort() count() 运算符（operators）： $ne $and $or $gt $lt $exists $lte $regex 另见： Query Documents Query and Projection Operators mongo Shell Methods Update Records下面显示了与更新表中现有记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 UPDATE … SET SQL 语句 123UPDATE peopleSET status = \"C\"WHERE age &gt; 25 Mongodb 语句 1234db.people.updateMany( &#123; age: &#123; $gt: 25 &#125; &#125;, &#123; $set: &#123; status: \"C\" &#125; &#125;) UPDATE … INC SQL 语句 123UPDATE peopleSET age = age + 3WHERE status = \"A\" Mongodb 语句 1234db.people.updateMany( &#123; status: \"A\" &#125; , &#123; $inc: &#123; age: 3 &#125; &#125;) 有关示例中使用的方法和运算符的详细信息，请参阅： db.collection.updateMany() $gt $set $inc 另见： Update Documents Update Operators db.collection.updateOne() db.collection.replaceOne() Delete Records下面显示了与从表中删除记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 DELETE WHERE SQL 语句 12DELETE FROM peopleWHERE status = \"D\" Mongodb 语句 1db.people.deleteMany( &#123; status: \"D\" &#125; ) DELETE SQL 语句 1DELETE FROM people Mongodb 语句 1db.people.deleteMany(&#123;&#125;) 有关更多信息，请参见 db.collection.deleteMany()。 Delete Documents db.collection.deleteOne() 看到这里，想必大家应该已经将脑海中 SQL 相关的知识和 MongoDB 一一对应起来了，那么剩下的就需要大家多多的实践，深入挖掘。 但是无论何时，都要记住，MongoDB 官方文档 绝对是你能找到的最权威、最全面的资料。","pubDate":"Sun, 07 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/07/sql-to-mongo-1/","category":"全栈开发"},{"title":"Taro 3.0 RC：React/Vue/Nerv 任你选","link":"https://aotu.io/notes/2020/05/25/taro-3-rc/","description":"在 Taro Next 预览版（Alpha）版本之后，我们没有停下迭代的步伐，经过两个月的开发和数百次提交之后，我们谨慎但坚定地发布 Taro Next 测试（Beta） 版，Beta 版发布后，社区很多开发者使用上了 Taro Next，他们的帮助和赞誉加上我们内部项目使用的良好反馈，Beta 发布一个月之后，我们非常自信地发布了候选版（RC）版本。 在稳定的 Beta 版本里，Taro 也添加了更多的功能： H5 编译支持H5 编译支持是我们版本升级最重要的理由之一。这意味着原来开发者写的小程序应用，现在可以直接运行在 Web 中。添加 H5 支持非常简单，只需要在项目根目录安装 @tarojs/webpack-runner，运行 taro build —type h5 —watch 即可： 12$ npm i -D @tarojs/webpack-runner@next$ taro build —type h5 —watch 和小程序一样，Taro Next 的 H5 端相较于之前版本的 Taro 是一次彻底的重写：基础组件现在全部使用 Web Components 构建，路由系统也完全与前端框架解耦，因此在 H5 端 Taro 也实现了跨框架。不管开发者使用的是 React、Vue 还是 Nerv，都可以同时运行在各种小程序和 H5 上。 微信小程序转 React/Vue早在 Taro 1.2 发布 时，我们就提供微信小程序转 Taro 的功能，转换后的微信小程序应用会变成一个多端应用。现在这个功能也完全兼容 Taro Next 的新架构，并且转换后的代码提供 React 和 Vue 两种选项。和以前一样，只需要在微信小程序项目根目录执行命令 taro convert ： 1$ taro convert 选择想要转换后的框架即可： 渲染 HTML 字符串在小程序中渲染 HTML 字符串通常会使用 wxparse 这样的第三方库，但 wxparse 的 API 复杂，拓展性弱，内部实现不准确，最重要的是现在已经停止了维护。比起 wxparse，Taro Next 的 HTML 字符串渲染提供以下的特性： API 与 Web 保持一致，可以直接通过 React 的 dangerouslySetInnerHTML 或 Vue 的 v-html 调用。 可以通过 CSS 直接控制标签样式 给已经渲染的 HTML 标签绑定事件 在 HTML 解析和渲染都提供了钩子函数满足个性化渲染需求 你可以访问文档渲染 HTML了解更多信息。 CSS-in-JS在 React 社区有一个著名的 CSS-in-JS 解决方案: styled-components。但遗憾的是，styled-components 使用 &lt;style&gt; 标签来动态地控制样式，在小程序端没有类似的方案。但在 Taro 中我们可以通过 linaria 实现同样的功能，linaria 主要提供以下特性： 近似于 styled-components 的 API 完整的 TypeScript 支持 零运行时 其中零运行时对于打包体积有要求的小程序尤为重要。 你可以访问文档使用 CSS-in-JS了解更多信息。 虚拟列表（VirtualList）当我们渲染数据量非常大的列表时，框架会根据数据尝试全量渲染视图，这就可能会产生性能问题导致视图无法响应操作一段时间。为了解决这个问题，我们可以采用另一种方式：比起全量渲染数据生成的视图，可以只渲染 当前可视区域(visable viewport) 的视图，非可视区域的视图在用户滚动到可视区域再渲染： 正常渲染和虚拟列表的区别 在开发者工具的直观效果 类似的技术在 Android 开发被称之为 RecyclerView，在 React Native 叫做 VirtualizedList，我们统一命名为虚拟列表（Virtual List），这个组件现在内置在 Taro 中，在 React/Vue 或各种小程序及 H5 皆可使用： 1import VirtualList from '@tarojs/components/virtual-list' 你可以访问文档长列表渲染了解更多信息。 插件功能自 2.2 开始，Taro 引入了插件化机制，允许开发者通过编写插件的方式来为 Taro 拓展更多功能或者为自身业务定制个性化功能。 该特性在 Taro next 中也可以使用了，官方提供了一个简易的数据 mock 插件 @tarojs/plugin-mock 供大家参考。相关接口和介绍可以通过 官方文档 -&gt; 进阶指南 -&gt; 插件功能 找到。 向正式版前进在 Beta 版本发布之后，除了 React Native 端兼容这一特性在迭代，我们主要的精力投入到 Taro 本身的开源治理和项目治理中，为了保证重大特性更新和架构更改能够顺利推进，我们推出了 Taro 的 RFC 流程机制，这将让 Taro 的进化更加透明公开，同时更多的社区参与势必让 Taro 更加完善。 期间，我们也对文档进行了升级，新文档相比旧版调整了部分目录让信息更合理，查找更方便，内容也更完善，同时也让阅读体验更加友好。 RC 版本，几乎就不会加入新的功能了，主要着重于除错，而后我们将发布正式版。也就是说： 如果你更为关注小程序端及 H5 端的开发，现在就是加入 Taro Next 最好的时机！ 感谢 感谢 skywalker512 大佬 修复了 Current type definition, 删除不能使用的 useScope 定义的问题(#5764)； 添加了支持 CSS Variables 的特性 (#5796)； 修复了 windows 下的路径问题(#5839)； 修复了 animation 定义出错的问题 (#5901)。 感谢 fupengl 大佬 修复了 webpack 配置多余参数导致 webpack,loader 参数校验失败的问题；（#5835）； 修复了 react 页面卸载生命周期没有调用的问题(#5826)； 修复了缺少 tt 样式文件匹配的问题； 修复了 input maxlength 拼写错误 (#6005)； 修复属性数字类型 0 也是有效值 (#6027)； 修复了编译原生 tt 小程序样式文件没有 loader 处理的问题 (#6088)。 感谢 wuchangming 大佬 修复了 webpack resolve.modules 设置绝对路径导致的依赖引用错误 (#5858)； 修复了 Current.router 获取的数据有误的问题 (#5989)。 感谢 cncolder 大佬 添加 linaria 配置和 webpack 配置 (#5880)； html typo (#5893)； 将 rich-text 属性设置为可选； 增加路由信息 path 字段 (#5898)； ui interaction 中的三个函数参数都是可选的 (#6351)。 感谢 Garfield550 大佬 给 api 增加 cjs 分发，规范部分包的文件包含 (#5991) ； 修复组件 animation 属性和 Animation.export() 方法的类型(#6025) 。 感谢fishead 添加了 framework 检查 (#5977)； 感谢 alexloading 大佬修改了 nextTick 适配小程序 setData 回调#5978； 感谢 hvsy 、cuikangyi、 yesmeck、Psli 大佬 。","pubDate":"Mon, 25 May 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/05/25/taro-3-rc/","category":"小程序"},{"title":"一个学习 Koa 源码的例子","link":"https://aotu.io/notes/2020/05/18/koa-demo/","description":"「Moa」一个学习 Koa 源码的例子 学习目标： 原生 node 封装 中间件 路由 静态文件服务（未完成待续） Koa 原理一个 nodejs 的入门级 http 服务代码如下，12345678910// index.jsconst http = require('http')const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200) res.end('hello nodejs')&#125;)server.listen(3000, () =&gt; &#123; console.log('server started at port 3000')&#125;) koa 的目标是更简单化、流程化、模块化的方式实现回调，我们希望可以参照 koa 用如下方式来实现代码： 123456789101112// index.jsconst Moa = require('./moa')const app = new Moa()app.use((req, res) =&gt; &#123; res.writeHeader(200) res.end('hello, Moa')&#125;)app.listen(3000, () =&gt; &#123; console.log('server started at port 3000')&#125;) 所以我们需要创建一个 moa.js 文件，该文件主要内容是创建一个类 Moa， 主要包含 use() 和 listen() 两个方法 12345678910111213141516171819// 创建 moa.jsconst http = require('http')class Moa &#123; use(callback) &#123; this.callback = callback &#125; listen(...args) &#123; const server = http.createServer((req, res) =&gt; &#123; this.callback(req, res) &#125;) server.listen(...args) &#125;&#125;module.exports = Moa Contextkoa 为了能够简化 API，引入了上下文 context 的概念，将原始的请求对象 req 和响应对象 res 封装并挂载到了 context 上，并且设置了 getter 和 setter ，从而简化操作 12345678910111213// index.js// ...// app.use((req, res) =&gt; &#123;// res.writeHeader(200)// res.end('hello, Moa')// &#125;)app.use(ctx =&gt; &#123; ctx.body = 'cool moa'&#125;)// ... 为了达到上面代码的效果，我们需要分装 3 个类，分别是 context, request, response , 同时分别创建上述 3 个 js 文件， 123456789101112131415161718192021222324252627282930313233343536// request.jsmodule.exports = &#123; get url() &#123; return this.req.url &#125; get method() &#123; return this.req.method.toLowerCase() &#125;&#125;// response.jsmodule.exports = &#123; get body() &#123; return this._body &#125; set body(val) = &#123; this._body = val &#125;&#125;// context.jsmodule.exports = &#123; get url() &#123; return this.request.url &#125; get body() = &#123; return this.response.body &#125; set body(val) &#123; this.response.body = val &#125; get method() &#123; return this.request.method &#125;&#125; 接着我们需要给 Moa 这个类添加一个 createContext(req, res) 的方法, 并在 listen() 方法中适当的地方挂载上： 12345678910111213141516171819202122232425262728293031// moa.jsconst http = require('http')const context = require('./context')const request = require('./request')const response = require('./response')class Moa &#123; // ... listen(...args) &#123; const server = http.createServer((req, res) =&gt; &#123; // 创建上下文 const ctx = this.createContext(req, res) this.callback(ctx) // 响应 res.end(ctx.body) &#125;) server.listen(...args) &#125; createContext(req, res) &#123; const ctx = Object.create(context) ctx.request = Object.create(request) ctx.response = Object.create(response) ctx.req = ctx.request.req = req ctx.res = ctx.response.res = res &#125;&#125; 中间件Koa 中间键机制：Koa 中间件机制就是函数组合的概念，将一组需要顺序执行的函数复合为一个函数，外层函数的参数实际是内层函数的返回值。洋葱圈模型可以形象表示这种机制，是 Koa 源码中的精髓和难点。 同步函数组合假设有 3 个同步函数: 123456789101112131415// compose_test.jsfunction fn1() &#123; console.log('fn1') console.log('fn1 end')&#125;function fn2() &#123; console.log('fn2') console.log('fn2 end')&#125;function fn3() &#123; console.log('fn3') console.log('fn3 end')&#125; 我们如果想把三个函数组合成一个函数且按照顺序来执行，那通常的做法是这样的： 123// compose_test.js// ...fn3(fn2(fn1())) 执行 node compose_test.js 输出结果： 123456fn1fn1 endfn2fn2 endfn3fn3 end 当然这不能叫做是函数组合，我们期望的应该是需要一个 compose() 方法来帮我们进行函数组合，按如下形式来编写代码： 12345// compose_test.js// ...const middlewares = [fn1, fn2, fn3]const finalFn = compose(middlewares)finalFn() 让我们来实现一下 compose() 函数，1234567891011121314// compose_test.js// ...const compose = (middlewares) =&gt; () =&gt; &#123; [first, ...others] = middlewares let ret = first() others.forEach(fn =&gt; &#123; ret = fn(ret) &#125;) return ret&#125;const middlewares = [fn1, fn2, fn3]const finalFn = compose(middlewares)finalFn() 可以看到我们最终得到了期望的输出结果： 123456fn1fn1 endfn2fn2 endfn3fn3 end 异步函数组合了解了同步的函数组合后，我们在中间件中的实际场景其实都是异步的，所以我们接着来研究下异步函数组合是如何进行的，首先我们改造一下刚才的同步函数，使他们变成异步函数, 12345678910111213141516171819// compose_test.jsasync function fn1(next) &#123; console.log('fn1') next &amp;&amp; await next() console.log('fn1 end')&#125;async function fn2(next) &#123; console.log('fn2') next &amp;&amp; await next() console.log('fn2 end')&#125;async function fn3(next) &#123; console.log('fn3') next &amp;&amp; await next() console.log('fn3 end')&#125;//... 现在我们期望的输出结果是这样的: 123456fn1fn2fn3fn3 endfn2 endfn1 end 同时我们希望编写代码的方式也不要改变, 12345// compose_test.js// ...const middlewares = [fn1, fn2, fn3]const finalFn = compose(middlewares)finalFn() 所以我们只需要改造一下 compose() 函数，使他支持异步函数就即可:1234567891011121314151617181920212223// compose_test.js// ...function compose(middlewares) &#123; return function () &#123; return dispatch(0) function dispatch(i) &#123; let fn = middlewares[i] if (!fn) &#123; return Promise.resolve() &#125; return Promise.resolve( fn(function next() &#123; return dispatch(i + 1) &#125;) ) &#125; &#125;&#125;const middlewares = [fn1, fn2, fn3]const finalFn = compose(middlewares)finalFn() 运行结果： 123456fn1fn2fn3fn3 endfn2 endfn1 end 完美！！！ 完善 Moa我们直接把刚才的异步合成代码移植到 moa.js 中, 由于 koa 中还需要用到 ctx 字段，所以我们还要对 compose() 方法进行一些改造才能使用： 123456789101112131415161718192021// moa.js// ...class Moa &#123; // ... compose(middlewares) &#123; return function (ctx) &#123; return dispatch(0) function dispatch(i) &#123; let fn = middlewares[i] if (!fn) &#123; return Promise.resolve() &#125; return Promise.resolve( fn(ctx, function () &#123; return dispatch(i + 1) &#125;) ) &#125; &#125; &#125;&#125; 实现完 compose() 方法之后我们继续完善我们的代码，首先我们需要给类在构造的时候，添加一个 middlewares，用来记录所有需要进行组合的函数，接着在use() 方法中把我们每一次调用的回调都记录一下，保存到middlewares 中，最后再在合适的地方调用即可： 12345678910111213141516171819202122232425// moa.js// ...class Moa &#123; constructor() &#123; this.middlewares = [] &#125; use(middleware) &#123; this.middlewares.push(middleware) &#125; listen(...args) &#123; const server = http.createServer(async (req, res) =&gt; &#123; // 创建上下文 const ctx = this.createContext(req, res) const fn = this.compose(this.middlewares) await fn(ctx) // 响应 res.end(ctx.body) &#125;) server.listen(...args) &#125; // ...&#125; 我们加一小段代码测试一下: 123456789101112131415161718// index.js//...const delay = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve() , 2000))app.use(async (ctx, next) =&gt; &#123; ctx.body = \"1\" await next() ctx.body += \"5\"&#125;)app.use(async (ctx, next) =&gt; &#123; ctx.body += \"2\" await delay() await next() ctx.body += \"4\"&#125;)app.use(async (ctx, next) =&gt; &#123; ctx.body += \"3\"&#125;) 运行命令 node index.js 启动服务器后，我们访问页面 localhost:3000 查看一下，发现页面显示 12345 ！ 到此，我们简版的 Koa 就已经完成实现了。让我们庆祝一下先！！！ RouterKoa 还有一个很重要的路由功能，感觉缺少路由就缺少了他的完整性，所以我们简单介绍下如何实现路由功能。 其实，路由的原理就是根据地址和方法，调用相对应的函数即可，其核心就是要利用一张表，记录下注册的路由和方法，原理图如下所示： 使用方式如下： 1234567891011// index.js// ...const Router = require('./router')const router = new Router()router.get('/', async ctx =&gt; &#123; ctx.body = 'index page' &#125;)router.get('/home', async ctx =&gt; &#123; ctx.body = 'home page' &#125;)router.post('/', async ctx =&gt; &#123; ctx.body = 'post index' &#125;)app.use(router.routes())// ... 我们来实现下 router 这个类，先在根目录创建一个 router.js 文件，然后根据路由的原理，我们实现下代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// router.jsclass Router &#123; constructor() &#123; this.stacks = [] &#125; register(path, method, middleware) &#123; this.stacks.push(&#123; path, method, middleware &#125;) &#125; get(path, middleware) &#123; this.register(path, 'get', middleware) &#125; post(path, middleware) &#123; this.register(path, 'post', middleware) &#125; routes() &#123; return async (ctx, next) =&gt; &#123; let url = ctx.url === '/index' ? '/' : ctx.url let method = ctx.method let route for (let i = 0; i &lt; this.stacks.length; i++) &#123; let item = this.stacks[i] if (item.path === url &amp;&amp; item.method === method) &#123; route = item.middleware break &#125; &#125; if (typeof route === 'function') &#123; await route(ctx, next) return &#125; await next() &#125; &#125;&#125;module.exports = Router 启动服务器后，测试下 loacalhost:3000, 返回页面上 index page 表示路由实现成功！","pubDate":"Mon, 18 May 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/05/18/koa-demo/","category":"全栈开发"},{"title":"大规格文件的上传优化","link":"https://aotu.io/notes/2020/05/12/file-upload/","description":"在开发过程中，收到这样一个问题反馈，在网站上传 100 MB 以上的文件经常失败，重试也要等老半天，这就难为需要上传大规格文件的用户了。那么应该怎么做才能快速上传，就算失败了再次发送也能从上次中断的地方继续上传呢？下文为你揭晓答案~ 温馨提示：配合 Demo 源码一起阅读效果更佳 整体思路第一步是结合项目背景，调研比较优化的解决方案。文件上传失败是老生常谈的问题，常用方案是将一个大文件切片成多个小文件，并行请求接口进行上传，所有请求得到响应后，在服务器端合并所有的分片文件。当分片上传失败，可以在重新上传时进行判断，只上传上次失败的部分，减少用户的等待时间，缓解服务器压力。这就是分片上传文件。 大文件上传那么如何实现大文件分片上传呢？ 流程图如下： 分为以下步骤实现： 1. 文件 MD5 加密MD5 是文件的唯一标识，可以利用文件的 MD5 查询文件的上传状态。 根据文件的修改时间、文件名称、最后修改时间等信息，通过 spark-md5 生成文件的 MD5。需要注意的是，大规格文件需要分片读取文件，将读取的文件内容添加到 spark-md5 的 hash 计算中，直到文件读取完毕，最后返回最终的 hash 码到 callback 回调函数里面。这里可以根据需要添加文件读取的进度条。 实现方法如下： 123456789101112131415161718192021222324252627282930313233343536373839// 修改时间+文件名称+最后修改时间--&gt;MD5md5File (file) &#123; return new Promise((resolve, reject) =&gt; &#123; let blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice let chunkSize = file.size / 100 let chunks = 100 let currentChunk = 0 let spark = new SparkMD5.ArrayBuffer() let fileReader = new FileReader() fileReader.onload = function (e) &#123; console.log('read chunk nr', currentChunk + 1, 'of', chunks) spark.append(e.target.result) // Append array buffer currentChunk++ if (currentChunk &lt; chunks) &#123; loadNext() &#125; else &#123; let cur = +new Date() console.log('finished loading') // alert(spark.end() + '---' + (cur - pre)); // Compute hash let result = spark.end() resolve(result) &#125; &#125; fileReader.onerror = function (err) &#123; console.warn('oops, something went wrong.') reject(err) &#125; function loadNext () &#123; let start = currentChunk * chunkSize let end = start + chunkSize &gt;= file.size ? file.size : start + chunkSize fileReader.readAsArrayBuffer(blobSlice.call(file, start, end)) &#125; loadNext() &#125;)&#125; 2. 查询文件状态前端得到文件的 MD5 后，从后台查询是否存在名称为 MD5 的文件夹，如果存在，列出文件夹下所有文件，得到已上传的切片列表，如果不存在，则已上传的切片列表为空。 123456789101112131415161718192021// 校验文件的MD5checkFileMD5 (file, fileName, fileMd5Value, onError) &#123; const fileSize = file.size const &#123; chunkSize, uploadProgress &#125; = this this.chunks = Math.ceil(fileSize / chunkSize) return new Promise(async (resolve, reject) =&gt; &#123; const params = &#123; fileName: fileName, fileMd5Value: fileMd5Value, &#125; const &#123; ok, data &#125; = await services.checkFile(params) if (ok) &#123; this.hasUploaded = data.chunkList.length uploadProgress(file) resolve(data) &#125; else &#123; reject(ok) onError() &#125; &#125;)&#125; 3. 文件分片文件上传优化的核心就是文件分片，Blob 对象中的 slice 方法可以对文件进行切割，File 对象是继承 Blob 对象的，因此 File 对象也有 slice 方法。 定义每一个分片文件的大小变量为 chunkSize，通过文件大小 FileSize 和分片大小 chunkSize 得到分片数量 chunks，使用 for 循环和 file.slice() 方法对文件进行分片，序号为 0 - n，和已上传的切片列表做比对，得到所有未上传的分片，push 到请求列表 requestList。 12345678910111213141516171819202122232425async checkAndUploadChunk (file, fileMd5Value, chunkList) &#123; let &#123; chunks, upload &#125; = this const requestList = [] for (let i = 0; i &lt; chunks; i++) &#123; let exit = chunkList.indexOf(i + '') &gt; -1 // 如果已经存在, 则不用再上传当前块 if (!exit) &#123; requestList.push(upload(i, fileMd5Value, file)) &#125; &#125; console.log(&#123; requestList &#125;) const result = requestList.length &gt; 0 ? await Promise.all(requestList) .then(result =&gt; &#123; console.log(&#123; result &#125;) return result.every(i =&gt; i.ok) &#125;) .catch(err =&gt; &#123; return err &#125;) : true console.log(&#123; result &#125;) return result === true&#125; 4. 上传分片调用 Promise.all 并发上传所有的切片，将切片序号、切片文件、文件 MD5 传给后台。 后台接收到上传请求后，首先查看名称为文件 MD5 的文件夹是否存在，不存在则创建文件夹，然后通过 fs-extra 的 rename 方法，将切片从临时路径移动切片文件夹中，结果如下： 当全部分片上传成功，通知服务端进行合并，当有一个分片上传失败时，提示“上传失败”。在重新上传时，通过文件 MD5 得到文件的上传状态，当服务器已经有该 MD5 对应的切片时，代表该切片已经上传过，无需再次上传，当服务器找不到该 MD5 对应的切片时，代表该切片需要上传，用户只需上传这部分切片，就可以完整上传整个文件，这就是文件的断点续传。 12345678910111213141516171819202122232425262728// 上传chunkupload (i, fileMd5Value, file) &#123; const &#123; uploadProgress, chunks &#125; = this return new Promise((resolve, reject) =&gt; &#123; let &#123; chunkSize &#125; = this // 构造一个表单，FormData是HTML5新增的 let end = (i + 1) * chunkSize &gt;= file.size ? file.size : (i + 1) * chunkSize let form = new FormData() form.append('data', file.slice(i * chunkSize, end)) // file对象的slice方法用于切出文件的一部分 form.append('total', chunks) // 总片数 form.append('index', i) // 当前是第几片 form.append('fileMd5Value', fileMd5Value) services .uploadLarge(form) .then(data =&gt; &#123; if (data.ok) &#123; this.hasUploaded++ uploadProgress(file) &#125; console.log(&#123; data &#125;) resolve(data) &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125; 5. 上传进度虽然分片批量上传比大文件单次上传会快很多，也还是有一段加载时间，这时应该加上上传进度的提示，实时显示文件上传进度。 原生 Javascript 的 XMLHttpRequest 有提供 progress 事件，这个事件会返回文件已上传的大小和总大小。项目使用 axios 对 ajax 进行封装，可以在 config 中增加 onUploadProgress 方法，监听文件上传进度。 123456const config = &#123; onUploadProgress: progressEvent =&gt; &#123; var complete = (progressEvent.loaded / progressEvent.total * 100 | 0) + '%' &#125;&#125;services.uploadChunk(form, config) 6. 合并分片上传完所有文件分片后，前端主动通知服务端进行合并，服务端接受到这个请求时主动合并切片，通过文件 MD5 在服务器的文件上传路径中找到同名文件夹。从上文可知，文件分片是按照分片序号命名的，而分片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接。所以应该在合并文件夹里的分片文件前，根据文件名进行排序，然后再通过 concat-files 合并分片文件，得到用户上传的文件。至此大文件上传就完成了。 Node 端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 合并文件exports.merge = &#123; validate: &#123; query: &#123; fileName: Joi.string() .trim() .required() .description('文件名称'), md5: Joi.string() .trim() .required() .description('文件md5'), size: Joi.string() .trim() .required() .description('文件大小'), &#125;, &#125;, permission: &#123; roles: ['user'], &#125;, async handler (ctx) &#123; const &#123; fileName, md5, size &#125; = ctx.request.query let &#123; name, base: filename, ext &#125; = path.parse(fileName) const newFileName = randomFilename(name, ext) await mergeFiles(path.join(uploadDir, md5), uploadDir, newFileName, size) .then(async () =&gt; &#123; const file = &#123; key: newFileName, name: filename, mime_type: mime.getType(`$&#123;uploadDir&#125;/$&#123;newFileName&#125;`), ext, path: `$&#123;uploadDir&#125;/$&#123;newFileName&#125;`, provider: 'oss', size, owner: ctx.state.user.id, &#125; const key = encodeURIComponent(file.key) .replace(/%/g, '') .slice(-100) file.url = await uploadLocalFileToOss(file.path, key) file.url = getFileUrl(file) const f = await File.create(omit(file, 'path')) const files = [] files.push(f) ctx.body = invokeMap(files, 'toJSON') &#125;) .catch(() =&gt; &#123; throw Boom.badData('大文件分片合并失败，请稍候重试~') &#125;) &#125;,&#125; 总结本文讲述了大规格文件上传优化的一些做法，总结为以下 4 点： Blob.slice 将文件切片，并发上传多个切片，所有切片上传后告知服务器合并，实现大文件分片上传； 原生 XMLHttpRequest 的 onprogress 对切片上传进度的监听，实时获取文件上传进度； spark-md5 根据文件内容算出文件 MD5，得到文件唯一标识，与文件上传状态绑定； 分片上传前通过文件 MD5 查询已上传切片列表，上传时只上传未上传过的切片，实现断点续传。 参照 Demo 源码 可快速上手上述功能，希望本文能对你有所帮助，感谢阅读❤️","pubDate":"Tue, 12 May 2020 10:08:08 GMT","guid":"https://aotu.io/notes/2020/05/12/file-upload/","category":"Web开发"},{"title":"京喜前端自动化测试之路","link":"https://aotu.io/notes/2020/05/06/jingxi-automated-testing/","description":"前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 原来的容灾演习过程：小程序（通信方式改成 Https ）和 H5 通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降级处理符合预期。容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景模拟异常导致演习效率很低，因此想通过开发自动化测试工具来提升研发效率，让容灾演习工作随时可以轻松开展。京喜 H5 和小程序场景差异比较大，因此自动化测试之路分 H5 和小程序两部分进行，以 H5 作为一个开篇。 综上所述，我们希望京喜 H5 自动化测试工具可以提供以下功能： 访问目标页面，对页面进行截图； 设置 UA（模拟不同渠道：微信、手Q、其它浏览器等）； 模拟用户点击、滑动页面操作； 网络拦截、模拟异常情况（接口响应码 500、接口返回数据异常）； 操作缓存数据（模拟有无缓存的场景等）。 技术选型提到 Web 的自动化测试，很多人熟悉的是 Selenium 2.0（Selenium WebDriver）， 支持多平台、多语言、多款浏览器（通过各种浏览器的驱动来驱动浏览器），提供了功能丰富的API接口。而随着前端技术的发展，Selenium 2.0 逐渐呈现出环境安装复杂、API 调用不友好、性能不高等缺点。新一代的自动化测试工具 —— Puppeteer ，相较于 Selenium WebDriver 环境安装更简单、性能更好、效率更高、在浏览器执行 Javascript 的 API 更简单，它还提供了网络拦截等功能。 Puppeteer 是一个 Node 库，它提供了一套高阶 API ，通过 Devtools 协议控制 Chromium 或 Chrome 浏览器。Puppeteer 默认以 Headless 模式运行，但是可以通过修改配置文件运行“有头”模式。 官方描述的功能： 生成页面 PDF； 抓取 SPA（单页应用）并生成预渲染内容（即“ SSR ”，服务器端渲染）； 自动提交表单，进行 UI 测试，键盘输入等； 创建一个时时更新的自动化测试环境，使用 JavaScript 和最新的浏览器功能直接在最新版本的 Chrome 中执行测试； 捕获网站的 Timeline Trace，用来帮助分析性能问题； 测试浏览器扩展。 Puppeteer 提供了一种启动 Chromium 实例的方法。 当 Puppeteer 连接到一个 Chromium 实例的时候会通过 puppeteer.launch 或 puppeteer.connect 创建一个 Browser 对象，在通过 Browser 创建一个 Page 实例，导航到一个 Url ，然后保存截图。一个 Browser 实例可以有多个 Page 实例。 下面就是使用 Puppeteer 进行自动化的一个典型示例： 1234567const puppeteer = require('puppeteer');puppeteer.launch().then(async browser =&gt; &#123; const page = await browser.newPage(); await page.goto('https://example.com'); await page.screenshot(&#123;path: 'screenshot.png'&#125;); await browser.close();&#125;); 综上所述，我们选择基于 Puppeteer 来开发京喜首页容灾演习的自动化测试工具，通过 Puppeteer 提供的一系列 API ，实现访问目标页面、模拟异常场景、生成截图的过程自动化。最后再通过人工比对截图，判断页面降级处理是否符合预期、用户体验是否友好。 实现方案我们将容灾演习过程分为自动化流程和人工操作两部分。 自动化流程： 模拟用户访问页面操作； 拦截网络请求，修改接口返回数据，模拟异常场景（接口返回 500、异常数据等）； 生成截图。 人工操作： 自动化脚本执行完毕后，人工比对各个场景的截图，判断是否符合预期。 方案流程图： 开发实录安装 Puppeteer ，你可能会遇到的那些事通过 npm init 初始化项目后， 就可以安装 Puppeteer 依赖了： npm i puppeteer ：在安装时自动下载最新版本 Chromium。 或者 npm i puppeteer-core ：在安装时不会自动下载 Chromium。（不能生成截图） 另外，在安装过程中可能会因为下载 Chromium 导致报错，官网建议是先通过 npm i --save puppeteer --ignore-scripts 阻止下载 Chromium， 然后再手动下载 Chromium 。 手动下载后，需要配置指定路径，修改 index.js 文件 123456789101112const puppeteer = require('puppeteer');(async () =&gt; &#123; const browser = await puppeteer.launch(&#123; // 运行 Chromium 或 Chrome 可执行文件的路径（相对路径） executablePath: './chrome-mac/Chromium.app/Contents/MacOS/Chromium', headless: false &#125;); const page = await browser.newPage(); await page.goto('https://example.com'); await page.screenshot(&#123;path: 'screenshot.png'&#125;); browser.close();&#125;)(); 快速创建测试用例为了提高测试脚本的可维护性、扩展性，我们将测试用例的信息都配置到 JSON 文件中，这样编写测试脚本的时候，我们只需关注测试流程的实现。 测试用例 JSON 数据配置包括公用数据（global）和私有数据： 公用数据（global）：各测试用例都需要用到的数据，如：模拟访问的目标页面地址、名字、描述、设备类型等。 私有数据： 各测试用例特定的数据，如测试模块信息、API 地址、测试场景、预期结果、截图名字等数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"global\": &#123; \"url\": \"https://wqs.jd.com/xxx/index.shtml\", \"pageName\": \"index\", \"pageDesc\": \"首页\", \"device\": \"iPhone 7\" &#125;, \"homePageApi\": &#123; \"id\": 1, \"module\": \"home_page_api\", \"moduleDesc\": \"首页主接口\", \"api\": \"https://wqcoss.jd.com/xxx\", \"operation\": \"模拟响应码 500\", \"expectRules\": [ \"1. 显示异常信息、刷新按钮\", \"2. 点击刷新按钮，显示异常信息\", \"3. 恢复网络，点击刷新按钮，显示正常数据\" ], \"screenshot\": [ &#123; \"name\": \"normal\", \"desc\": \"正常场景\" &#125;, &#123; \"name\": \"500_cache\", \"desc\": \"有缓存-返回500\" &#125;, &#123; \"name\": \"500_no_cache\", \"desc\": \"无缓存-返回500\" &#125;, &#123; \"name\": \"500_no_cache_reload\", \"desc\": \"无缓存-返回500-点击刷新按钮\" &#125;, &#123; \"name\": \"500_no_cache_recover\", \"desc\": \"无缓存-返回500-恢复网络\" &#125; ] &#125;, …&#125; 编写测试脚本我们以京喜首页主接口的测试用例为例子，通过模接口返回 500 响应码的异常场景，验证主接口的异常处理机制是否完善、用户体验是否友好。 预期效果： 有缓存情况下，显示缓存数据 无缓存情况下显示异常信息、刷新按钮 点击刷新按钮，显示异常信息 恢复网络，点击刷新按钮，显示正常数据 测试流程： 场景实现： 根据测试流程以及配置的测试用例信息，编写测试脚本，实现测试用例场景: 访问页面 1await page.goto(url) 生成截图 123await page.screenshot(&#123; path: './screenshot/index_home_page_500.png'&#125;) 拦截接口请求 123456async test () =&gt; &#123; ... // 创建 Page 实例,访问首页 await page.setRequestInterception(true) // 设置拦截请求 page.on(\"request\", interceptionEvent) // 监听请求事件，当请求发起后页面会触发这个事件 ... // 刷新页面，触发请求拦截，生成测试场景截图&#125; 若测试用例需要拦截不同的请求，或是模拟多种场景，则需要设置多个请求监听事件。且一个事件执行结束后，必须要移除事件监听，才能继续下一个事件监听。 添加事件监听：page.on(&quot;request&quot;, eventFunction) 移除事件监听：page.off(&quot;request&quot;, eventFunction) 1234567891011121314151617181920// 设置拦截请求await page.setRequestInterception(true)const iconInterception1 = requestInterception(api, \"body\")// 添加事件 1 监听page.on(\"request\", iconInterception1)await page.goto(url)await page.screenshot(&#123; path: './screenshot/1.png'&#125;)// 移除事件 1 监听 page.off(\"request\", iconInterception1)const iconInterception2 = requestInterception(api, \"body\", )// 添加事件 2 监听page.on(\"request\", iconInterception2)await page.goto(url)await page.screenshot(&#123; path: './screenshot/2.png'&#125;)// 移除事件 2 监听page.off(\"request\", iconInterception2) 模拟异常数据场景，生成 mock 数据。 1234567891011121314151617181920212223242526272829function requestInterception (api, setProps, setValue) &#123; let mockData switch (setProps) &#123; case \"status\": // 修改返回状态码 mockData = &#123; status: setValue &#125; break case \"contentType\": // 修改返回内容类型 mockData = &#123; contentType: setValue &#125; break case \"body\": // 修改返回数据 mockData = &#123; contentType: getMockResponse(setValue) &#125; break default: break &#125; return async req =&gt; &#123; // 如果是需要拦截的 API，则通过 req.respond(mockData) 修改返回数据，否则 continue 继续请求别的 if (req.url().includes(api)) &#123; // 拦截 API req.respond(mockData) // 修改返回数据 return false // 处理完了某个请求必须退出，不再执行 continue &#125; req.continue()&#125; 模拟接口返回 500：12const interception500 = requestInterception(api, 'status', 500)page.on(\"request\", interception500) // 当请求发起后页面会触发这个事件 模拟异常数据：123456789const iconInterception = requestInterception(api, \"body\", &#123; \"data\": &#123; \"modules\": [&#123; \"tpl\": \"3000\", \"content\": [] &#125;] &#125;&#125;)page.on(\"request\", iconInterception) 生成 mock 数据有两种实现方案，可依据实际情况而定： 直接通过修改接口真实返回的数据生成 mock 数据，需要先获取接口实时返回数据 本地存储一份完整的接口数据，通过修改本地存储数据的方式生成 mock 数据（本文所述案例均基于此方案实现） 若选择第一种方案，则需先拦截接口请求，通过 req.response() 获取接口实时返回数据，根据测试场景修改实时返回数据作为 mock 数据。 由于京喜 H5 页面接口返回是 JSONP 格式的数据，所以在模拟返回数据的时候，必须先截取 JSONP 的 callback 信息，与模拟数据拼接后再返回； 12345678910111213141516171819202122232425262728293031function requestInterception (api, setProps, setValue) &#123; let mockData switch (setProps) &#123; case \"status\": mockData = &#123; status: setValue &#125; break case \"contentType\": mockData = &#123; contentType: setValue &#125; break default: break &#125; return async req =&gt; &#123; if (req.url().includes(api)) &#123; if (setProps === \"body\") &#123; const callback = getUrlParam(\"callback\", req.url()) // 获取 callback 信息 const localData = getLocalMockResponse(api) // 匹配 API ，获取本地存储数据 mockData = &#123; body: getResponseMockLocalData(localData, setValue, callback, api) // 生成 mock 数据 &#125; &#125; req.respond(mockData) // 设置返回数据 return false &#125; req.continue() &#125; &#125; 清除缓存 12345678page.evaluate(() =&gt; &#123; try &#123; localStorage.clear() sessionStorage.clear() &#125; catch (e) &#123; console.log(e) &#125;&#125;) 点击刷新按钮 12await page.waitFor(\".page-error__refresh-btn\") // 可以传 CSS 选择器，也可以传时间（单位毫秒）await page.click(\".page-error__refresh-btn\") 在模拟点击刷新按钮之前，需等待按钮渲染完成，再触发按钮点击。（防止刷新页面后，DOM 还未渲染完成的情况下，因找不到 DOM 导致报错） 取消拦截，恢复网络 1await page.setRequestInterception(false) 运行脚本及调试由于第一阶段的测试工具尚未平台化，自动化测试流程先通过在终端输入命令行，运行脚本的方式启动。 在项目的 package.json 文件中，使用 scripts 字段定义脚本命令： 1234\"scripts\": &#123; \"test:real\": \"node ./pages/index/index.js\", \"test:mock\": \"node ./pages/index-mock/index.js\" &#125;, 运行： 在终端切入到项目根目录路径，输入以下命令行，就可以启动测试工具，运行测试脚本。 - npm run test:real // 接口真实返回的数据测试 - npm run test:mock // 使用本地 mock 数据测试 调试： 开启调试模式之前，需要先了解 Headless Chrome。 Headless Chrome ，无头模式，浏览器的无界面形态，可以在不打开浏览器的前提下，在命令行中运行测试脚本，能够完全像真实浏览器一样完成用户所有操作，不用担心运行测试脚本时浏览器受到外界的干扰，也不需要借助任何显示设备，使自动化测试更稳定。 Puppeteer 默认以无头模式运行。 那么要开启调试模式，就必须取消无头模式，在打开浏览器的场景下，进行自动化测试。因此，在命令行脚本中增加了“取消无头模式”和“打开开发者工具”的参数，测试脚本通过获取到的参数，决定是否开启调试模式。 1234567const headless = process.argv[2] !== 'head' // 获取是否开启无头模式参数const devtools = process.argv[3] === 'dev' // 获取是否打开开发者工具参数const browser = await puppeteer.launch(&#123; executablePath: browserPath, headless, devtools &#125;) 在终端切入到项目根目录路径，输入以下命令行，就可以开启调试模式，运行测试脚本。 - npm run test:mock head // 打开 Chromium 窗口 - npm run test:mock head dev // 打开 Chromium 窗口 和 开发者工具窗口 head 参数：取消无头模式，打开 Chromium 窗口运行脚本； head dev 参数：在打开 Chromium 窗口运行脚本，并打开 Devtools 窗口，开启调试模式。 测试结果人工比对截图结果： 运行脚本示例： 更多测试场景实现1. 截取从页面顶部到指定 DOM 之间的区域（内容可能超出一屏的长图） Puppeteer 提供了四种截图方式： （1）截取一屏内容（默认普通截屏）； （2）截取指定 DOM； （3）截取全屏； （4）指定裁剪区域，可设置 x、y、width、height。 x, y 是相对页面左上角。但只能截取一屏的内容，超出一屏不展示。 基于第四种方法进行改造： 通过原生 JavaScript 的 getBoundingClientRect() 方法获取到指定 DOM 的 x，y 坐标值； 通过 page.setViewport() 重置视口的高度； 调用截图 API 生成截图。 12345678910111213141516171819202122async function screenshotToElement (page, selector, path) &#123; try &#123; await page.waitForSelector(selector) let clip = await page.evaluate(selector =&gt; &#123; const element = document.querySelector(selector) let &#123; x, y, width, height &#125; = element.getBoundingClientRect() return &#123; x: 0, y: 0, width, height: M(y), &#125; &#125;, selector) await page.setViewport(clip) await page.screenshot(&#123; path: path, clip: clip &#125;) &#125; catch (e) &#123; console.log(e) &#125; &#125; height: y：截到指定 DOM 的顶部，不包含该 DOM； height: y + height： 截到指定 DOM 的底部，包含该 DOM； 原生 Javascript 的 getBoundingClientRect() 方法获取 DOM 元素定位和宽高值可能是小数，而 Puppeteer 的 setViewport() 设置视口方法不支持小数，所以需要对获取到的 DOM 元素定位信息取整。 2. 模拟不同渠道，如：手Q场景： 12// 设置 UA await page.setUserAgent(\"Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 (KHTML, like Gecko) Mobile/14D27 QQ/6.7.1.416 V1_IPH_SQ_6.7.1_1_APP_A Pixel/750 Core/UIWebView NetType/4G QBWebViewType/1\") 3. 滚动页面 123await page.evaluate((top) =&gt; &#123; window.scrollTo(0, top)&#125;, top) page.evaluate(pageFunction, …args)：在当前页面实例上下文中执行 JavaScript 代码 4. 监听页面崩溃事件1234// 当页面崩溃时触发page.on('error', (e) =&gt; &#123; console.log(e)&#125;) 结语第一阶段的 H5 自动化之路告一段落，容灾演习已实现了半自动化，可通过在终端运行测试脚本，模拟异常场景自动生成截图，再配合人工比对截图操作，判断演习结果是否符合预期。目前已投入到每个月的容灾演习中使用。 随着京喜业务的迭代，页面也将更新改版，因此测用例也需要持续维护和更新。后续将持续优化自动化工具，共享测试脚本、在生成截图的基础上自动比对测试结果是否符合预期、数据入库、将测试结果转化成文档，自动发送邮件等等。基于容灾演习的自动化测试，还可扩展广告位的监测，数据上报监自动化测试…… 对于京喜首页自动化测试之路，远没有结束，还有很多可以优化和扩展的地方，接下来分阶段持续优化自动化测试工具，敬请期待！ 相关链接 Puppeteer","pubDate":"Wed, 06 May 2020 04:51:08 GMT","guid":"https://aotu.io/notes/2020/05/06/jingxi-automated-testing/","category":"Web开发"},{"title":"京东小程序 Taro 开发对比原生开发测评","link":"https://aotu.io/notes/2020/04/27/taro-vs-jd/","description":"Taro 自 1.3.20 版本开始支持转换为京东小程序，受到了很多同学的关注。当中有欢呼雀跃的声音：“一键转换为京东小程序，终于可以准时下班啦”。也有对 Taro 不太了解的同学提出了一些疑问：“转换的效果如何？”、“转换后代码的性能是否达标？”等等。 针对各种疑问，我们从性能与开发体验的角度切入，把京东小程序原生开发与 Taro 开发进行了一番对比。 性能对比针对性能的问题，我们分别测试了 Taro 空项目的包大小和 Taro 在长列表中的表现。因为包大小会影响小程序的首次加载速度，而长列表则是常常出现性能瓶颈的场景。 Taro 空项目包大小目前各小程序都有对主包的大小进行限制，如京东小程序限制为 5M、微信小程序限制为 2M。这是因为初次进入的速度对于用户的体验非常地关键，而主包体积越大下载的时间就最长。因此小程序框架的大小也成为了开发前框架选型的重要参考指标之一，倘若框架体积过大，就会压缩业务逻辑的可用空间。 下列图片分别是 Taro 运行时框架压缩前后的大小，可以看到压缩后仅为84k，对主包空间的影响十分小。 压缩前： 压缩后： 长列表渲染表现benchmark 介绍我们参照 js-framework-benchmark 编写了一份 benchmark，测试对比了 Taro 代码与原生代码在长列表场景下的渲染表现。 测速指标 初始化：从进入页面开始到完成 40 个商品的渲染。 创建：页面 onLoad 后创建 40 个商品。 增加：往已创建了 40 个商品的列表中每次增加 20 个商品。 部分更新：在 400 个商品中更新每第 10 个商品的名称。 交换：在 400 个商品中交换其中两个商品的位置。 选中：点击商品图片，改变商品名称的字体颜色。 计时点Taro： 开始：事件响应函数的顶部。 结束：setState 回调函数的顶部。 原生小程序： 开始：事件响应函数的顶部。 结束：setData 回调函数的顶部。 其它benchmark 仓库：Github Taro 版本：1.3.21 测试机型：魅蓝 note 测试方法：每组测试 10 条数据，去除其中最大值与最小值后求平均值 测试结果因为在京东小程序与微信小程序中，setData 的 callback 的触发时机稍有不同，所以分开列出。 操作 Taro jd 原生京东小程序 初始化 150 123 创建 87 85 部分更新 125 235 交换 140 213 选中 131 155 操作 Taro weapp 原生微信小程序 初始化 1155 1223 创建 500 408 部分更新 167 307 交换 252 309 选中 193 178 经测试发现，列表的长度会对增加操作的耗时产生影响：列表越长，增加操作的耗时越久。因此不能简单地对 N 次增加操作求平均增加耗时。这里我们选择使用折线图来展现出随增加操作次数的变化，渲染耗时的变化趋势。 测试结论创建 在创建时，Taro 会对数据做一些处理，因此会比原生稍慢。 初始化 初始化与创建相比，差别是引入了页面构造耗时。即初始化耗时 = 页面构造耗时 + 创建操作耗时。 Taro 在页面初始化、创建操作时都会对数据进行处理，因此整个初始化耗时会比原生稍慢。 那为什么微信小程序中 Taro 初始化耗时更短呢？在 benchmark 中 Taro 和原生分别在 componentWillMount 和 onLoad 渲染列表，而 Taro 使用 Component 构造页面，componentWillMount 其实是在 attached 生命周期中触发。因为在微信小程序中 attached 比 onLoad 早触发得多，所以会出现如此现象。 选中 因为 Taro 只是把回调函数包装了一层，处理了事件参数和 this 等，所以和原生的速度相当。 部分更新、交换、增加 Taro 的速度会优于原生。原因是 Taro 会先对将要 setData 的数据和当前 data 的数据做一次 diff，这能够大大减少 setData 的数据量，加快渲染速度。对比两个折线图可以得知，数据量越大，diff 的优化收益也越大。 Taro 对小程序的性能优化setData在小程序中，性能的问题主要在于单次 setData 数据量过大和频繁调用 setData 上。Taro 利用 diff 解决了单次 setData 数据量过大的问题，而对于频繁调用 setData 也有解决的办法。 Taro 的 setState 遵循 React 规范，不同于 setData 的同步更新，它会异步地去更新视图。因此假设开发者在单次事件循环中多次调用 setState，最后也只会在下一个事件循环中进行一次 setData。 跳转预加载小程序由 A 页面跳转到 B 页面的过程中，从 A 页面发起跳转到 B 页面触发 onLoad，有着 300~400 毫秒的延时。Taro 提供了 componentWillPreload 钩子，钩子会在发起跳转后立即执行。开发者可以尽早地在钩子里做一些数据拉取的工作，相比在 onLoad 触发后再去拉取数据就能够节省 300~400 毫秒的延时。 shouldComponentUpdate &amp; Taro.PureComponent开发者的 Class Component 可以继承 Taro.PureComponent，这样组件在更新前会对新旧 props 和新旧 state 各做一次浅对比，避免不必要的更新。当然开发者可以自己实现 shouldComponentUpdate，通过手动控制新旧 props 和新旧 state 的对比，决定是否更新组件。 Taro.memo如果开发者书写的是函数式组件，则可以利用 Taro.memo 实现 shouldComponentUpdate 的相同功能。 开发体验对比语法京东小程序的原生语法和微信小程序相仿，都是类 MVVM 语法，没有接触过小程序的开发者有一定学习成本。另外样式语法为 css 的子集，其中自适应尺寸单位为 rpx，这样意味着如果我们需要 css 预处理器时需要手动配置工作流，并且在编写样式时处处注意尺寸单位的转换。 目前 Taro 遵循 React 语法（将来会支持所有 Web 前端框架），JSX 令我们的代码更加灵活。因此拥有 React 开发经验的开发者可以马上上手 Taro 的开发工作。在样式方面 Taro 支持在创建项目时选择是否使用 css 预处理器，选择后会自动配置相应的工作流。对于样式单位 Taro 也会把用户编写的 px 数值自动转换成对应的 rpx 数值，开发者无需再分心处理各平台的样式单位。 项目结构原生开发中，页面和组件各由4个文件（js、jxml、jxss、json）所组成，代码管理相对麻烦。 Taro 中页面和组件均由一份 js 文件和一份样式文件组成，创建与维护十分容易。 开发生态微信小程序经过不断迭代，相继推出了插件系统和支持引用 npm 包的功能。但京东小程序暂不支持前两者，京东小程序社区也还没打造起来，开发生态资源十分匮乏。 Taro 中不但能自由引用 npm 包，而且还大量支持 React 社区中沉淀的优秀工具和库，如 react-redux、mobx-react 等。 开发辅助京东小程序原生开发不支持 Typescript，只能在 IDE 的编辑器中有自动补全功能，编码效率不高，同时也容易出错。 Taro 完美支持 Typescript，自带代码智能提示和代码实时检查功能，能让开发效率大大提升。 写在最后看到这里大家可能会问，Taro 性能真的优于原生吗？其实并不然，针对每个场景，我们都可以用原生写出性能最佳的代码。但是这样做工作量太大，实际项目开发中需要掌握效率与优化之间的平衡。Taro 的优势在于能让我们在书写更有效率的代码、拥有更丰富的生态的同时，还带来了不错的性能。 最后，欢迎大家来使用 Taro 开发各端应用，有任何开发问题欢迎在Taro 论坛 或 GitHub 上和我们交流，我们会第一时间回复。 相关链接 Taro 官方网站 Taro 文档 Taro 论坛","pubDate":"Mon, 27 Apr 2020 07:15:08 GMT","guid":"https://aotu.io/notes/2020/04/27/taro-vs-jd/","category":"Taro"},{"title":"使用 Taro 快速开发京东小程序","link":"https://aotu.io/notes/2020/04/27/taro-build-jd/","description":"近两年来小程序逐渐成为互联网的一个行业风口，一直备受业界关注，各大厂也接踵推出了自己的小程序。近日京东也推出了小程序：京东小程序。Taro 作为一款专注于多端统一开发的框架，第一时间对京东小程序进行了适配。接下来就跟着小编一起了解一下如何使用 Taro 快速开发京东小程序吧。 背景京东小程序京东小程序平台是京东自研技术（能力）开放平台，平台集成京东特色功能，串联商家和用户。为用户提供延展服务，给商家带来新机遇。京东小程序平台不仅支持存量自营、POP商家自动开通，还支持新型的非电商领域商家参与小程序生态。 加入京东小程序开放平台的商家，可以利用京东平台完整的营销、交易、支付、会员、物流等能力，更加便捷地构建起自己的特色服务场景。助力商家实现生态场景上的“跃迁”，快速为用户提供一站式服务体验。 京东小程序只需一次开发即可运行在京东 APP、京东金融 APP、京麦 APP 三端。京东 APP、京东金融 APP 会开放特定的能力，对优质小程序还会开放多个高流量入口，包含扫码、搜索、消息等多种方式触达。而京麦 APP 小程序主要用于商家工具插件的开发定制。 TaroTaro 是凹凸实验室推出的一套遵循 React 语法规范的多端统一开发解决方案，也是京东小程序官方推荐的开发框架。 使用 Taro 开发不但能更规范、更有效率地编码， 畅享 React / Vue 生态的各种工具。更重要的是只需编写一份代码，即可运行在各种平台：京东/微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等。 如今 Taro 正被广泛用于京东各大业务，例如京东购物（微信）、京喜（微信、H5、RN）、京东好物街（微信、百度、字节跳动）、京东到家（微信、H5）等，在业界也被各大型业务广泛应用，如：58 同城、喜茶、腾讯吐个槽社区等等。 使用 Taro 快速开发京东小程序入驻京东小程序进入京东小程序官网，提交相关信息后完成入驻。 开发1.安装 Taro 的 CLI 工具： 1npm install -g @tarojs/cli 已安装 Taro 的同学请注意更新 Taro 版本，Taro 自 1.3.20 后支持转换京东小程序。 2.使用 CLI 创建项目： 1taro init [projectName] 3.进入项目根目录，使用 CLI 编译项目，根据 Taro 文档 进行开发： 1taro build --type jd [--watch] 4.调试 申请入驻京东小程序成功后，京东小程序会给开发者发放邀请码，同时提供开发者工具下载，下载后可使用开发者工具进行调试。 Taro 已完全适配京东小程序Taro 已 100% 完成了转换京东小程序的工作，全面支持京东小程序的各种特性。 开发中如遇到任何问题或困难，欢迎在 Github Issues、Taro 社区进行反馈，或联系 **taro@jd.com**，我们会尽快给予答复与支持。 示例项目转换效果图小编尝试把 Taro Github 上学习资源中的优秀开源项目：仿严选多端项目 分别转换为微信小程序端和京东小程序端，对比可见转换非常完美，表现效果基本一致。 微信小程序端 京东小程序端 未来规划Taro 团队对于京东小程序是充满期待和信心的。为此我们讨论并规划了一系列工作，由底层框架适配，到辅助业务落地、拓展京东小程序生态，再到京东小程序的可视化自助搭建等，目前已经完成物料市场的部分物料适配验证并标记支持京东小程序、体验可视化自助搭建请点击这个链接按照指引申请体验权限。 期待大家参与共建有任何意见建议、业务支持、合作诉求的，尽请发送邮件到 **taro@jd.com**，我们会第一时间回复。 心动不如行动，现在就开始使用 Taro 开发你的京东小程序吧～ 了解更多关于京东小程序《京东小程序平台，他来了》","pubDate":"Mon, 27 Apr 2020 06:55:08 GMT","guid":"https://aotu.io/notes/2020/04/27/taro-build-jd/","category":"Taro"},{"title":"智能可视化搭建系统 Atom 服务架构演变","link":"https://aotu.io/notes/2020/04/21/atom-services-upgrade/","description":"Atom 是什么？Atom 是集结业内各色资深电商行业设计师，提供一站式专业智能页面和小程序设计服务的平台。经过 2 年紧凑迭代，项目越来越庞大，需求不断变更优化，内部逻辑错综复杂，维护成本急剧拉升。同时，Atom 将要承载的业务越来越多，要向更多的内部用户和商家提供服务，为了适应这些变化，架构升级成为当时紧迫的事项，我们将解构服务端模块，让服务轻量化、模块化，更便捷地拓展业务场景。 Atom 服务端经历了三个版本的迭代，本文着重剖析第三个版本。 架构 1.0这是 Atom 最古老的一个版本，在这一版本中，只规划了频道页的功能，目的是把开发人员从繁复的频道页开发中解放出来，因为功能目的纯粹，所以系统复杂度较低，服务端直接使用了 Koa 框架上手开发，这是一个单体架构的服务，所有的代码都在一个进程中运行。 在部署方面，运用的是非常原始的手工操作：开发人员登入机器，拉取代码后进行类似本地环境的安装启动，然后在不同机器重复这个过程。 另外，Quark 的旧版本使用的是具名组件，具名组件一定程度限制了 Quark 自身的扩展性，这里不作展开。 架构 2.0从频道页搭建平台到多场景页面搭建平台，Atom 用了不到一年时间，更丰富的组件，更多的模板，更多的场景，更多参与进来的设计师，更多的用户，产品开发逐渐专业化，简单的手工运维已经不再适用，于是前端和服务端都进行了一次大换血，服务端用 Salak 重构，Salak 是个非常好上手的服务端框架，同时为我们带来了接口文档的自动化生成功能，前端和服务端都改为依靠 Talos（一容器式部署内部平台）来部署。服务端逐渐迈入工业时代。 然而，这个阶段仍然没解决粗放的开发方式，缺乏宏观上的规划，日益暴露了以下这些问题： 高度集中 90% 以上服务集中于一个单体架构中，业务越来越复杂，代码量越来越大，代码的可读性、可维护性和可扩展性下降，开发人员接入成本剧增，业务扩展的代价成指数上升，持续交付能力难以维持。随着用户越来越多，程序承受的并发越来越高，单体架构的应用的并发能力有限。由于系统复杂度的提高，测试的难度也越来越大。 耦合度高 单体中的各个模块间互相依赖，互相影响，互相掣肘，导致代码重用性低，新功能开发往往由于忌惮耦合逻辑中的隐藏彩蛋，而选择重新编写，这不是我们希望看到的！ 逻辑混乱 除了耦合导致的逻辑混乱，Atom 作为一个从零成长起来的平台，本身就淤积了大量的历史需求，有些是不再使用的，有些是几乎不被使用的，这些代码逻辑给开发人员一个极大的挑战：在进行代码维护的时候不敢轻易改动代码。另外在迭代中需要向下兼容，让服务端有沉重的历史包袱。 代码冗余 由于框架在前期没有定义好规范标准，在开发过程比较严格遵守代码校验，代码的逻辑、常量等等重复定义，这也同时让项目变得难以维护，比如修改一个常量需要在保证没有遗漏的前提同时修改多处。 新架构目标根据原有架构的优劣，我们设置了本次架构升级的目标： 服务模块化 服务通用化 插拔式站点 插拔式场景 标准与规范 名词解释： 站点：即把服务端与平台解耦，从原来的服务即平台，到可以为互相隔离的多个平台提供相同的服务。 场景：为应对不同业务类型而设定的概念，不同场景有不同的管理方式和流程等。 整体架构整体架构分为 Web 应用层、接口层、服务层 和 数据层 4 部分，这样拆分能做到入口统一，在部署上的单点部署让发布更加的便捷，独立部署则降低对服务整体的影响： Web 应用层：包括 Atom 平台及其他的平台应用 接口层：提供网关服务，应用层的请求经由网关作权限控制及请求转发 服务层： 服务通信：异步通信使用 MQ，RPC 通信使用 HTTP 业务模块：核心代码，拆解众多小模块应用 基础服务：统一把控用户与权限 服务管理：提升服务的稳定性、健壮性、灵活性 数据层：核心数据存储 其中网关作为整个服务端的流量入口，对所有流量进行处理，拦截非法请求，解析登录态并传递到下游，校验接口权限以及超时响应等，统一把控，同时减轻下游的压力。 实施计划/筹备/评估在正式进入升级开发前，小组通过会议探讨架构升级的必要性和可行性，促使我们进行升级的直接原因是平台新增的站点需求和场景需求，如要在原有架构上实现这个需求，势必会在原已混乱的逻辑上增添更多的耦合逻辑，而间接原因，亦即升级必要性，则是要让系统模块化、标准化、通用化，让系统的逻辑更加清晰，提升整个系统的可维护性。 经过我们反复的探讨，对原系统按照功能进行分割，在功能的基础上再按照通用性进行进一步拆分，附加新架构的支撑性工作，评估这些工作的工作量和预计用时，最后对任务进行分配下达。 实施模块化为什么要模块化？随着平台越做越大，我们想要让各个部分的功能更加独立、明确、清晰，把各部分之间的影响降到最低，对各部分单独运维，避免牵一发而动全身的情况。 这次升级按照功能和通用性把项目划分为 10+ 个模块：如专门负责编译的模块，专门负责模板管理的模块，负责定时任务的模块，作为入口的网关等等。 其中拆分出来若干通用服务，通用服务作为独立于 Atom 系统之外的服务，可以为 Atom 以及其他系统提供服务。 对项目进行模块拆解，最为头疼的是斩断关联逻辑，模块的剥离和修复必然会导致一个问题——相同的代码在不同的模块重复出现。为了解决这个问题，我们把部分这些代码放到工具 npm 包中，这些代码包括了：常量、TypeScript 类型定义、权限映射、Mongoose Schema 定义、Salak 插件和工具方法等等。 另一个问题，在原架构中，模块间可以通过代码直接调用，那新架构中如何“还原”这个功能？为了保证解耦度，新架构中仅有少数需要即时调用的功能在模块间通过接口进行直接调用，其他的都是通过 MQ 消息队列和数据库进行互通。 对于 MQ 通信，这里举个例子：编译。服务端编译通常需要的时间比较长，长时间占用连接对服务性能有所影响，而且编译结果并不需要同步响应，对编译模块来说，如果来者不拒，对服务有不小的压力，于是我们决定使用消息队列来完成各个模块之间的通信： 由项目模块通过接口直接调用发布模块发起发布操作； 发布模块向消息池推送一条“我要编译”； 编译模块接收到消息后由自身情况判断是否可以进入编译，否则先不予以响应； 编译的各个状态也通过消息推送； 最后项目模块在接收到编译状态的消息后作各种处理。 通用化前面提到在模块化的工作中，我们拆出了 4 个通用的服务模块，通用服务独立于 Atom 系统之外，可以为 Atom 以及其他系统提供服务。模块的通用化是出于两点考虑： 丰富部门的服务，减少重复开发功能 排除 Atom 非核心代码，让系统瘦身 伴随而来的一个问题值得我们思考，如何考量一个功能是否值得抽离通用化？我们应该尽量避免陷入一个误区：系统模块化就是把系统拆得越细越好。如果拆分过细，势必增加运维工作量。在拆分模块的时候，我们考量的是一个模块内的功能是否完整且独立，以及部门或公司对这个通用服务的需求度，真正地做到低耦合高内聚。 标准化代码层面，下面做了个简单的对比： 对比项 旧架构 新架构 主要语言 JavaScript TypeScript 代码检测 未遵守 必需 接口名称 花样百出 统一形式 接口输出 百花齐放 统一形式 TypeScript 的好，前端人都知道，它为我们带来了自动补全、可选的类型系统，使我们能够用上更加新的 JavaScript 特性等等，更多可以参考《为什么选择 TypeScript》。出现后面三点的原因是什么？旧架构经历了从零到一的过程，项目在最初规划欠缺以及中后期没有足够的时间对系统进行修正，时间和需求的变更的双重作用导致代码淤积。 为此，我们在新架构的开发中就强调代码的标准化，对每次提交都要经过代码检测，然后是对五花八门的接口进行统一： 接口路径统一：旧架构中，一个列表接口的路径可能是 /xxx/list，也可能是 /xxx/xxxes 等等，我们在新架构中基于 RESTful API 规则，用资源名词组成的路径和语义化的 HTTP 协议统一接口的定义； 参数名统一：比如列表入参中每页数量可能叫 pageSize 也可能叫 count，于是我们把它统一成一个名字，要求在开发中遵守这个约定； 输出统一：在数据输出到前端前对数据进行处理筛选，剔除包括 _id 和 __v 等无关数据，在输出形式上也做了统一，要求输出中所有的 _id 都替换以 id 的名字出现等等。 代码标准化的好处是让代码更加好维护，开发人员很快就能定位到对应的接口代码，对前端而言则减少对接口的识别记忆。 插拔式站点前面提到，这次架构升级的直接原因是站点需求和场景需求。如果在旧架构下迭代站点需求，只会进一步增加耦合度。为此，我们增加了站点管理模块，在几乎所有的数据项中增加了站点字段，给几乎所有的数据库查询都带上了站点参数。通过这些努力，现在新增站点只需要通过站点模块新增站点，再做一些初始化配置即可完成。 站点概念除对 Atom 功能有了更高要求，也对原来的权限体系形成了新的挑战。在升级前的版本中用户的权限仅有一个集合，要实现每个站点拥有不同的权限只能从两个角度出发： 权限含义拆分（为每个站点分别提供一套独立的权限） 用户权限增加一层抽象（用户的权限改变为多个集合根据站点进行切换） 在比较了两种修改形式后，拆分权限含义虽然在理解上比较容易代码也改动不多。但却大大提升了维护权限表的难度，相当于新增场景就需要增加一套权限，无法做到可插拔。最后在网关层增加了根据用户访问站点切换权限集合的逻辑。 插拔式场景场景是站点下面一个纬度，现有活动、频道、心理学测试、SNS、店铺几大场景，如果在旧架构下新增一个场景，需要排期进行开发，而且代码上恐怕也会增加不少针对不同场景的 if-else。为了更便捷省心地扩展和维护场景，我们对场景相关的代码从资源管理的角度做了拆解。 ATOM下每个场景拥有的资源主要有 模板/项目/标签/权限 四种： 12345标签 页面 | |模板------&gt;项目权限 首先介绍项目模块目录的结构，项目模块的代码基于 策略模式 组织，每个场景的业务逻辑拆分到单独文件，由调度器直接调用，避免不同场景间逻辑掺杂。 调度器文件命名为 base_资源_service 场景策略文件命名为 场景小写_资源_service 通用策略文件命名为 common_资源_service 当用户查询进来时，调度器根据查询的条件直接调用对应策略文件中的方法（一般不允许直接调用指定场景的策略除非确认不会关联到其他场景的数据），当调度器没有没有找到对应场景下的策略时，默认会调用 common_service 的逻辑，所以各场景需要继承 common_service。以页面管理服务为例，调度器为 src/service/page 目录下的 base_page_service，通用逻辑为 common_page_service，频道页场景逻辑为 ch_page_service。 出于对场景下公有方法的统一抽象，服务中常用的 CRUD 方法接口 放置在 AbstractServiceClass 文件中 123456├── src│ ├── service│ │ └── &#123;resource&#125;│ │ ├── base_&#123;resource&#125;_service 策略文件调用器,controller/mq 直接调用│ │ ├── common_&#123;resource&#125;_service 通用策略文件，例如列表查询共用的参数处理│ │ └── &#123;scene&#125;_&#123;resource&#125;_service 场景策略文件，场景特殊的 部署数据迁移鉴于这次升级的巨变，在新旧版本间的切换务必慎重，除了前端与服务端为此做的大量的联调外，我们还对数据进行了兼容性迁移，主要做法是通过迁移脚本把旧数据根据新架构的需要做多重处理，尔后写入新数据库中。 不中断部署在单体架构中，每一次服务的发布部署都会造成几分钟的空窗。 为避免这种情况，在生产环境，我们保证每个模块至少拥有两个容器，在部署的时候，把部分容器从负载均衡摘除，然后循环检测容器是否还有流量，直至没有流量进来才进行更新操作，服务启动后重新添加到负载均衡，然后对剩下的容器进行同样的操作，这样做的好处是，保证了整个部署过程，服务是不中断的，避免了部署过程中的空档情况。 运维为避免再重蹈旧架构下糟糕的运维体验及项目代码管理，我们为新架构梳理了一个运维文档，包括快速接入、开发、调试、部署方方面面的细节都尽可能详尽地记录下来。 为系统增加了监控，监控每个接口的性能和可用性。 效果经过这次升级，基本达成计划中的效果： 清晰：逻辑梳理、去除冗余、TS 重构、ESNext 模块化：解耦 10+ 模块，独立运作；HTTP、MQ、数据层等多通信方式 标准化：强代码规范；接口统一；响应统一 通用化：4+ 通用模块，平台无关；抽取公共库、配置、插件、中间件等 易迁移：一键初始化；一键、单点、独立部署；入口统一 易扩展：+新增站点拓展能力；调整场景拓展；节省人力时间成本 95%+ 易维护：追加日志；一键部署；不中断部署 易对接：完备的 Joi 文档；详尽的接口变更记录；尽可能的向上兼容 工具/方法/协作工具对项目的顺利进行有非常重要的影响，因此在这次升级中，我们尝试了多种工具。 为了保证项目成员对自己负责模块有清晰的了解以及对模块的改造有明确的图样，团队引入流程图工具用于梳理旧架构的模块并分工，梳理勾画新架构各个模块内部的逻辑等等。 在排期方面，我们实践使用到了甘特图，用甘特图按照模块对任务进行拆分，然后指派给对应的负责人并设置计划的进行时间，每天同步整体的进度，从甘特图可以清晰地了解项目的资源分配与排期，也能看到项目计划与实际的对照，有助于项目整体的进度把控。 甘特图对项目升级的任务进行了初步的划分，对于更细化的划分，我们放到了 IssueBoard，IssueBoard 像是一个简化版的任务看板，但对我们来说已经绰绰有余了，另外，选择它的理由还包括：它支持跟 git 提交进行联动，适合开发人员使用，可以通过每次提交来关闭相应的 Issue。 总结反思在这次升级过程中，也暴露了一些不足，主要体现在排期与预期以及在前期的沟通上。 排期与预期 在升级筹划初期的排期过于乐观，而且在升级过程中没有再进行修正，当然这是客观原因造成的，团队要在有限的需求空窗期内完成升级以避免同时维护两个版本，这导致的后果是团队必须每天比计划花更多的时间。 沟通 在服务端进行升级时，没有跟前端沟通具体的细节，而这次升级又是非完全向下兼容的，所以在联调的时候给造成前端一定的困扰和不便。 参考 Atom：https://ling.jd.com/atom Salak：https://salakjs.github.io/docs/docs/zh-cn/introduction.html RESTful API：http://www.ruanyifeng.com/blog/2014/05/restful_api.html","pubDate":"Tue, 21 Apr 2020 00:08:08 GMT","guid":"https://aotu.io/notes/2020/04/21/atom-services-upgrade/","category":"项目总结"},{"title":"Taro Next H5 跨框架组件库实践","link":"https://aotu.io/notes/2020/04/13/2020-4-13-taro-components/","description":"Taro 是一款多端开发框架。开发者只需编写一份代码，即可生成各小程序端、H5 以及 React Native 的应用。 Taro Next 近期已发布 beta 版本，全面完善对小程序以及 H5 的支持，欢迎体验！ 背景Taro Next 将支持使用多框架开发过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了升级，支持使用 React、Vue、Nerv 等框架开发多端应用。 为了支持使用多框架进行开发，Taro 需要对自身的各端适配能力进行改造。本文将重点介绍对 Taro H5 端组件库的改造工作。 Taro H5Taro 遵循以微信小程序为主，其他小程序为辅的组件与 API 规范。 但浏览器并没有小程序规范的组件与 API 可供使用，例如我们不能在浏览器上使用小程序的 view 组件和 getSystemInfo API。因此我们需要在 H5 端实现一套基于小程序规范的组件库和 API 库。 Taro H5 架构图： 在 Taro 1 和 Taro 2 中，Taro H5 的组件库使用了 React 语法进行开发。但如果开发者在 Taro Next 中使用 Vue 开发 H5 应用，则不能和现有的 H5 组件库兼容。 所以本文需要面对的核心问题就是：我们需要在 H5 端实现 React、Vue 等框架都可以使用的组件库。 方案选择我们最先想到的是使用 Vue 再开发一套组件库，这样最为稳妥，工作量也没有特别大。 但考虑到以下两点，我们遂放弃了此思路： 组件库的可维护性和拓展性不足。每当有问题需要修复或新功能需要添加，我们需要分别对 React 和 Vue 版本的组件库进行改造。 Taro Next 的目标是支持使用任意框架开发多端应用。倘若将来支持使用 Angular 等框架进行开发，那么我们需要再开发对应支持 Angular 等框架的组件库。 那么是否存在着一种方案，使得只用一份代码构建的组件库能兼容所有的 web 开发框架呢？ 答案就是 Web Components。 但在组件库改造为 Web Components 的过程并不是一凡风顺的，我们也遇到了不少的问题，故借此文向大家娓娓道来。 Web Components 简介Web Components 由一系列的技术规范所组成，它让开发者可以开发出浏览器原生支持的组件。 技术规范Web Components 的主要技术规范为： Custom Elements Shadow DOM HTML Template Custom Elements 让开发者可以自定义带有特定行为的 HTML 标签。 Shadow DOM 对标签内的结构和样式进行一层包装。 &lt;template&gt; 标签为 Web Components 提供复用性，还可以配合 &lt;slot&gt; 标签提供灵活性。 示例定义模板： 123&lt;template id=\"template\"&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/template&gt; 构造 Custom Element： 1234567891011121314class App extends HTMLElement &#123; constructor () &#123; super(...arguments) // 开启 Shadow DOM const shadowRoot = this.attachShadow(&#123; mode: 'open' &#125;) // 复用 &lt;template&gt; 定义好的结构 const template = document.querySelector('#template') const node = template.content.cloneNode(true) shadowRoot.appendChild(node) &#125;&#125;window.customElements.define('my-app', App) 使用： 1&lt;my-app&gt;&lt;/my-app&gt; Stencil使用原生语法去编写 Web Components 相当繁琐，因此我们需要一个框架帮助我们提高开发效率和开发体验。 业界已经有很多成熟的 Web Components 框架，一番比较后我们最终选择了 Stencil，原因有二： Stencil 由 Ionic 团队打造，被用于构建 Ionic 的组件库，证明经受过业界考验。 Stencil 支持 JSX，能减少现有组件库的迁移成本。 Stencil 是一个可以生成 Web Components 的编译器。它糅合了业界前端框架的一些优秀概念，如支持 Typescript、JSX、虚拟 DOM 等。 示例：创建 Stencil Component： 123456789101112131415161718192021import &#123; Component, Prop, State, h &#125; from '@stencil/core'@Component(&#123; tag: 'my-component'&#125;)export class MyComponent &#123; @Prop() first = '' @State() last = 'JS' componentDidLoad () &#123; console.log('load') &#125; render () &#123; return ( &lt;div&gt; Hello, my name is &#123;this.first&#125; &#123;this.last&#125; &lt;/div&gt; ) &#125;&#125; 使用组件： 1&lt;my-component first='Taro' /&gt; 在 React 与 Vue 中使用 Stencil到目前为止一切都那么美好：使用 Stencil 编写出 Web Components，即可以在 React 和 Vue 中直接使用它们。 但实际使用上却会出现一些问题，Custom Elements Everywhere 通过一系列的测试用例，罗列出业界前端框架对 Web Components 的兼容问题及相关 issues。下面将简单介绍 Taro H5 组件库分别对 React 和 Vue 的兼容工作。 兼容 React1. Props1.1 问题React 使用 setAttribute 的形式给 Web Components 传递参数。当参数为原始类型时是可以运行的，但是如果参数为对象或数组时，由于 HTML 元素的 attribute 值只能为字符串或 null，最终给 WebComponents 设置的 attribute 会是 attr=&quot;[object Object]&quot;。 attribute 与 property 区别 1.2 解决方案采用 DOM Property 的方法传参。 我们可以把 Web Components 包装一层高阶组件，把高阶组件上的 props 设置为 Web Components 的 property： 1234567891011121314151617181920212223242526272829303132333435363738const reactifyWebComponent = WC =&gt; &#123; return class extends React.Component &#123; ref = React.createRef() update () &#123; Object.entries(this.props).forEach(([prop, val]) =&gt; &#123; if (prop === 'children' || prop === 'dangerouslySetInnerHTML') &#123; return &#125; if (prop === 'style' &amp;&amp; val &amp;&amp; typeof val === 'object') &#123; for (const key in val) &#123; this.ref.current.style[key] = val[key] &#125; return &#125; this.ref.current[prop] = val &#125;) &#125; componentDidUpdate () &#123; this.update() &#125; componentDidMount () &#123; this.update() &#125; render () &#123; const &#123; children, dangerouslySetInnerHTML &#125; = this.props return React.createElement(WC, &#123; ref: this.ref, dangerouslySetInnerHTML &#125;, children) &#125; &#125;&#125;const MyComponent = reactifyWebComponent('my-component') 注意： children、dangerouslySetInnerHTML 属性需要透传。 React 中 style 属性值可以接受对象形式，这里需要额外处理。 2. Events2.1 问题因为 React 有一套合成事件系统，所以它不能监听到 Web Components 发出的自定义事件。 以下 Web Component 的 onLongPress 回调不会被触发： 1&lt;my-view onLongPress=&#123;onLongPress&#125;&gt;view&lt;/my-view&gt; 2.2 解决方案通过 ref 取得 Web Component 元素，手动 addEventListener 绑定事件。 改造上述的高阶组件： 123456789101112131415161718192021222324252627282930313233const reactifyWebComponent = WC =&gt; &#123; return class Index extends React.Component &#123; ref = React.createRef() eventHandlers = [] update () &#123; this.clearEventHandlers() Object.entries(this.props).forEach(([prop, val]) =&gt; &#123; if (typeof val === 'function' &amp;&amp; prop.match(/^on[A-Z]/)) &#123; const event = prop.substr(2).toLowerCase() this.eventHandlers.push([event, val]) return this.ref.current.addEventListener(event, val) &#125; ... &#125;) &#125; clearEventHandlers () &#123; this.eventHandlers.forEach(([event, handler]) =&gt; &#123; this.ref.current.removeEventListener(event, handler) &#125;) this.eventHandlers = [] &#125; componentWillUnmount () &#123; this.clearEventHandlers() &#125; ... &#125;&#125; 3. Ref3.1 问题我们为了解决 Props 和 Events 的问题，引入了高阶组件。那么当开发者向高阶组件传入 ref 时，获取到的其实是高阶组件，但我们希望开发者能获取到对应的 Web Component。 domRef 会获取到 MyComponent，而不是 &lt;my-component&gt;&lt;/my-component&gt; 1&lt;MyComponent ref=&#123;domRef&#125; /&gt; 3.2 解决方案使用 forwardRef 传递 ref。 改造上述的高阶组件为 forwardRef 形式： 123456789101112131415const reactifyWebComponent = WC =&gt; &#123; class Index extends React.Component &#123; ... render () &#123; const &#123; children, forwardRef &#125; = this.props return React.createElement(WC, &#123; ref: forwardRef &#125;, children) &#125; &#125; return React.forwardRef((props, ref) =&gt; ( React.createElement(Index, &#123; ...props, forwardRef: ref &#125;) ))&#125; 4. Host’s className4.1 问题在 Stencil 里我们可以使用 Host 组件为 host element 添加类名。 1234567891011121314import &#123; Component, Host, h &#125; from '@stencil/core';@Component(&#123; tag: 'todo-list'&#125;)export class TodoList &#123; render () &#123; return ( &lt;Host class='todo-list'&gt; &lt;div&gt;todo&lt;/div&gt; &lt;/Host&gt; ) &#125;&#125; 然后在使用 &lt;todo-list&gt; 元素时会展示我们内置的类名 “todo-list” 和 Stencil 自动加入的类名 “hydrated”： 但如果我们在使用时设置了动态类名，如： &lt;todo-list class={this.state.cls}&gt;。那么在动态类名更新时，则会把内置的类名 “todo-list” 和 “hydrated” 抹除掉。 关于类名 “hydrated”： Stencil 会为所有 Web Components 加上 visibility: hidden; 的样式。然后在各 Web Component 初始化完成后加入类名 “hydrated”，将 visibility 改为 inherit。如果 “hydrated” 被抹除掉，Web Components 将不可见。 因此我们需要保证在类名更新时不会覆盖 Web Components 的内置类名。 4.2 解决方案高阶组件在使用 ref 为 Web Component 设置 className 属性时，对内置 class 进行合并。 改造上述的高阶组件： 123456789101112131415161718192021222324252627282930const reactifyWebComponent = WC =&gt; &#123; class Index extends React.Component &#123; update (prevProps) &#123; Object.entries(this.props).forEach(([prop, val]) =&gt; &#123; if (prop.toLowerCase() === 'classname') &#123; this.ref.current.className = prevProps // getClassName 在保留内置类名的情况下，返回最新的类名 ? getClassName(this.ref.current, prevProps, this.props) : val return &#125; ... &#125;) &#125; componentDidUpdate (prevProps) &#123; this.update(prevProps) &#125; componentDidMount () &#123; this.update() &#125; ... &#125; return React.forwardRef((props, ref) =&gt; ( React.createElement(Index, &#123; ...props, forwardRef: ref &#125;) ))&#125; 兼容 Vue不同于 React，虽然 Vue 在传递参数给 Web Components 时也是采用 setAttribute 的方式，但 v-bind 指令提供了 .prop 修饰符，它可以将参数作为 DOM property 来绑定。另外 Vue 也能监听 Web Components 发出的自定义事件。 因此 Vue 在 Props 和 Events 两个问题上都不需要额外处理，但在与 Stencil 的配合上还是有一些兼容问题，接下来将列出主要的三点。 1. Host’s className1.1 问题同上文兼容 React 第四部分，在 Vue 中更新 host element 的 class，也会覆盖内置 class。 1.2 解决方案同样的思路，需要在 Web Components 上包装一层 Vue 的自定义组件。 123456789101112131415161718function createComponent (name, classNames = []) &#123; return &#123; name, computed: &#123; listeners () &#123; return &#123; ...this.$listeners &#125; &#125; &#125;, render (createElement) &#123; return createElement(name, &#123; class: ['hydrated', ...classNames], on: this.listeners &#125;, this.$slots.default) &#125; &#125;&#125;Vue.component('todo-list', createComponent('todo-list', ['todo-list'])) 注意： 我们在自定义组件中重复声明了 Web Component 该有的内置类名。后续开发者为自定义组件设置类名时，Vue 将会自动对类名进行合并。 需要把自定义组件上绑定的事件通过 $listeners 透传给 Web Component。 2. Ref2.1 问题为了解决问题 1，我们给 Vue 中的 Web Components 都包装了一层自定义组件。同样地，开发者在使用 ref 时取到的是自定义组件，而不是 Web Component。 2.2 解决方案Vue 并没有 forwardRef 的概念，只可简单粗暴地修改 this.$parent.$refs。 为自定义组件增加一个 mixin： 1234567891011121314151617181920212223242526export const refs = &#123; mounted () &#123; if (Object.keys(this.$parent.$refs).length) &#123; const refs = this.$parent.$refs for (const key in refs) &#123; if (refs[key] === this) &#123; refs[key] = this.$el break &#125; &#125; &#125; &#125;, beforeDestroy () &#123; if (Object.keys(this.$parent.$refs).length) &#123; const refs = this.$parent.$refs for (const key in refs) &#123; if (refs[key] === this.$el) &#123; refs[key] = null break &#125; &#125; &#125; &#125;&#125; 注意： 上述代码没有处理循环 ref，循环 ref 还需要另外判断和处理。 3. v-model3.1 问题我们在自定义组件中使用了渲染函数进行渲染，因此对表单组件需要额外处理 v-model。 3.2 解决方案使用自定义组件上的 model 选项，定制组件使用 v-model 时的 prop 和 event。 改造上述的自定义组件： 1234567891011121314151617181920212223242526272829303132333435363738export default function createFormsComponent (name, event, modelValue = 'value', classNames = []) &#123; return &#123; name, computed: &#123; listeners () &#123; return &#123; ...this.$listeners &#125; &#125; &#125;, model: &#123; prop: modelValue, event: 'model' &#125;, methods: &#123; input (e) &#123; this.$emit('input', e) this.$emit('model', e.target.value) &#125;, change (e) &#123; this.$emit('change', e) this.$emit('model', e.target.value) &#125; &#125;, render (createElement) &#123; return createElement(name, &#123; class: ['hydrated', ...classNames], on: &#123; ...this.listeners, [event]: this[event] &#125; &#125;, this.$slots.default) &#125; &#125;&#125;const Input = createFormsComponent('taro-input', 'input')const Switch = createFormsComponent('taro-switch', 'change', 'checked')Vue.component('taro-input', Input)Vue.component('taro-switch', Switch) 总结当我们希望创建一些不拘泥于框架的组件时，Web Components 会是一个不错的选择。比如跨团队协作，双方的技术栈不同，但又需要公用部分组件时。 本次对 React 语法组件库进行 Web Components 化改造，工作量不下于重新搭建一个 Vue 组件库。但日后当 Taro 支持使用其他框架编写多端应用时，只需要针对对应框架与 Web Components 和 Stencil 的兼容问题编写一个胶水层即可，总体来看还是值得的。 关于胶水层，业界兼容 React 的方案颇多，只是兼容 Web Components 可以使用 reactify-wc，配合 Stencil 则可以使用官方提供的插件 Stencil DS Plugin。倘若 Vue 需要兼容 Stencil，或需要提高兼容时的灵活性，还是建议手工编写一个胶水层。 本文简单介绍了 Taro Next、Web Components、Stencil 以及基于 Stencil 的组件库改造历程，希望能为读者们带来一些帮助与启迪。","pubDate":"Mon, 13 Apr 2020 03:10:00 GMT","guid":"https://aotu.io/notes/2020/04/13/2020-4-13-taro-components/","category":"Web开发"},{"title":"Electron 在 Taro IDE 的开发实践","link":"https://aotu.io/notes/2020/04/07/electron-in-taro-ide/","description":"这是一些使用 Electron 开发的经验与感悟 背景Taro IDE 是一款我们正在精心打造的一站式移动端研发工作台。除了需要实现 Taro 从创建项目到预览、编译的全部能力，还需要打通用户测试、调试、监控等一系列流程。为了提升开发体验，仅仅一个命令行工具是远远不够的，我们需要开发一款桌面客户端，并同时提供 Windows、MacOS 等不同系统的版本。 Electron 最初是 Github 为 Atom 编辑器开发的桌面应用框架。Electron 将 Chromium 与 Node 合并到同个运行时环境中，赋予了 Web 代码与底层操作系统进行交互的能力，并在打包时生成 Windows、MacOS、Linux 等平台的桌面应用。比起原生的桌面应用开发框架，Electron 在性能、应用体积方面会稍逊一筹，但 Electron 支持打包多个平台的桌面应用，在业界已经有 VSCode、Atom、Slack 等综合体验拔群的成功案例，我们认为 Electron 完全满足我们的需求。 介绍 Electron如果只想体验一下 Electron，最快的方式是使用 Electron Fiddle，或者直接使用社区中提供的 脚手架。 最初接触 Electron，一般是被“使用前端技术栈生成多平台桌面应用”的特性吸引。但在后续的开发中，才会留意到 Electron 相比 NW.js 更为复杂的进程模型： Electron 的架构可以用下图来表示： Electron 项目中，运行 package.json 的 main 脚本的进程被称为主进程。主进程通过创建 web 页面来展示用户界面。这些用户界面都运行在彼此隔离的渲染进程中。 Electron 主进程支持 Node API，并且可直接与操作系统进行底层交互，弹出系统通知、文件系统读写、调用硬件设备等。 Electron 渲染进程默认只能与自身的 Web 内容进行交互。在打开 nodeIntegration 功能后，渲染进程也可以具备操作 Node 的能力。渲染进程也无法直接操作弹窗（Dialog）、系统通知（Notification）等，这些功能都需要通过 Electron 提供的 IPC/remote 机制在主进程中调用。 并且在后续 Electron 的升级中，这些约束也可能因为安全、性能的原因进行调整。可以说，Electron 的开发体验并不太美好，但正是这种开发体验与用户体验之间的博弈，保证了 Electron 应用在性能、安全方面的表现。 开发工作流我们使用社区提供的 electron-react-typescript 作为项目的初始脚手架。阅读 package.json 文件，我们可以了解到，这个项目使用 webpack 进行主进程和渲染进程的打包，src/main/main.ts 文件就是主进程的入口。 Electron 的 BrowserWindow 类负责创建和控制浏览器窗口，app 对象则可以控制应用程序的各个事件与生命周期。 主进程的代码大致如下： 1234567891011import &#123; app, BrowserWindow &#125; from 'electron'let winapp.on('ready', () =&gt; &#123; win = new BrowserWindow(&#123; width: 800, height: 600 &#125;); win.loadURL(`http://localhost:2003`); // xxx&#125;);app.on('activate', () =&gt; &#123;&#125;)app.on('window-all-closed', () =&gt; &#123;&#125;) 渲染进程 src/renderer/app.tsx 就一个普通的页面，这里不再赘述。安装依赖后，使用 yarn start-dev ，即可启动项目的预览服务。 这个项目使用 webpack 来打包项目代码，这样处理有两个好处。一是通过 webpack 处理，我们可以减少运行时的 require 调用，对 Electron 应用加载性能有一定帮助；二是借助 webpack 的 tree shaking 能力，未使用的代码也会被轻松移除，可以有效减少安装包体积。 为了打包 electron 项目，我们需要至少两份 webpack 配置文件，一份打包主进程文件，指定 target 为 electron-main，另一份打包渲染进程，target 设置为 electron-renderer。 为了辅助 Electron 项目的调试工作，我们可以安装 Devtron。Devtron 是 Electron 提供的开发调试插件。在开发者工具中加入 Devtron 后，项目中的 IPC 通信、查看项目依赖、事件等信息，都可以在开发者工具中直接查看。 如有需要，我们还可以安装其他的开发者工具扩展，例如 Redux、React 等，只需要在主进程中运行： 1234567891011121314151617// main.jsconst &#123; default: installExtension, REACT_DEVELOPER_TOOLS, REACT_PERF, REDUX_DEVTOOLS&#125; = require('electron-devtools-installer')const extensions = [REACT_DEVELOPER_TOOLS, REDUX_DEVTOOLS, REACT_PERF]extensions.forEach(extension =&gt; &#123; try &#123; installExtension(extension) &#125; catch (e) &#123; console.error(e) &#125;&#125;) 至此，我们的开发环境搭建完毕，可以开始进行业务代码的开发了。 优化业务代码开发完毕后，就到了优化的环节了。这里主要从 Electron 应用的性能与体积两方面来讲。 性能Electron 在性能方面一直受到广大开发者的诟病。窗口打开慢，加载时间长都是老生畅谈的话题。这些问题该如何解决呢？ 答案是预加载。在展示登录窗口时，我们可以提前将主窗口开启并设置隐藏，预加载主窗口的静态资源。用户登录后，再通过 IPC 消息通知主窗口展示，达到秒开的效果。这个过程可以用下图表示： 除了窗口加载，在 Electron 中，require Node 模块也是相当昂贵的操作。如果在渲染进程中直接使用大量的原生模块，会严重拖慢页面的打开时间，造成窗口可交互时间的延后，这对于桌面应用来说是灾难性的体验。Electron@5 之后的版本已经默认关闭了 BrowserWindow 的 nodeIntegration 功能，可以看出 Electron 团队也并不建议在渲染进程中直接使用原生模块。 在桌面应用中，等待是非常难以忍受的，性能上的些许欠缺都会让用户觉得这是个套壳的网页。如需使用原生模块，我们更建议使用异步的方式加载模块，或是使用异步 IPC 在主进程中调用。另外，为了优化用户的体验，我们还需要在小动画等方面下功夫，例如骨架屏等等。 Atom 团队通过使用 V8 snapshot 能力，在生产环境中去掉了低性能的 require 调用，将 Electron 应用的加载性能提升了 30%，同时还提升了应用的安全性能，这篇文章 How Atom Uses Chromium Snapshots 对他们的做法做了详细介绍。 启用骨架屏前后对比： 性能优化的方式并不局限于上面的方式。例如开启 electron-builder 的 asar 功能，在打包时将源码生成二进制的 asar 文件，降低 require 操作的代价的同时，也能稍许减少空间占用，代价是无法对 asar 内的文件使用 child_process.spawn ；需要密集计算的功能，可以开多一个渲染进程来跑，或是使用 require(&#39;child_process&#39;).spawn 开子进程来跑，避免阻塞主进程，造成应用卡死。 体积同样受到开发者诟病的，还有 Electron 应用的体积 。一个空 Electron 项目，在打包后就会占据近上百兆空间。Electron 的应用体积之所以大，除了自带的 Chromium 内核，还有大部分体积是来自用户安装的 node_modules。 使用 electron-builder 打包 Electron 应用时，如果不加处理，会将 node_modules 内的内容全数打包，导致应用体积偏大。针对这种情况，我们可以进行一系列优化： 使用 yarn autoclean 命令进行清理。node_modules 目录中，包含着大量的 README 文件、文档等内容，这部分文件在生产环境中并非必要。如果项目中使用 yarn 进行依赖管理，则可以使用 yarn autoclean 命令。这个命令会初始化一份默认的配置文件 .yarnclean 。yarn 在安装依赖后，将会自动根据 .yarnclean 进行依赖清理。 12345678910111213141516171819# 默认的 .yarnclean 文件大致如下：# test directories__tests__testtestspowered-test# asset directoriesdocsdocwebsiteassets# examplesexampleexamples... 使用双 package.json 架构。node_modules 目录中，除了生产环境需要用到的依赖，还存在着很多 devDependencies，这部分依赖是不应该被打包的。为了解决这个问题，electron-builder 提供了双 package.json 架构。具体来说，electron-builder 推荐用户将 Electron 应用依赖划分为两部分：开发依赖以及生产依赖。用户使用项目根目录的 package.json 来管理开发依赖，而使用项目的应用文件夹下的 package.json 管理生产依赖。electron-builder 仅会打包应用文件夹下的依赖。 在这个改动后，安装依赖时还需要通过 electron-builder install-app-deps 命令安装应用依赖。这个操作推荐放在 package.json 内的 post-install 脚本中。 electron-builder@8 后，并不会打包 devDependencies 内的依赖。这意味着我们可以通过这个途径来避免开发依赖被打包的问题。如果项目使用了 webpack 之类的工具进行打包，则需要注意将 webpack 已经打包过的资源从 dependencies 中排除，避免重复打包。 未来能力 Web 化目前，项目的大部分能力依然是基于 Electron 提供的能力实现的。这相当于与 Electron 严重耦合，不利于项目中个别能力的复用。未来，我们希望对项目的架构进行调整，对核心能力进行插件化改造，方便能力的移植与复用，甚至未来的研发上云，这有赖于项目核心能力的 Web 化。当然，Web 化也会带来额外的性能损耗，这会对我们项目的性能提出新的要求。 崩溃处理项目的稳定性也是未来需要努力的方向。我们有时会收到用户关于应用闪退、卡死等现象的反馈，却苦于无法复现，很多时候难以解决用户反馈的问题。未来，我们需要在项目中加入异常监控上报的机制，收集操作系统信息、内存使用量等关键信息，在 Crash 时进行上报，甚至推送告警消息。这有利于开发人员进一步了解用户的使用过程，方便问题的复现。 小结在开发桌面应用时，Electron 在效率上有很大的优势。几行 JS 代码就可以启动桌面客户端，大大降低了开发门槛。但 Electron 在性能、体积等方面也存在着软肋。如果在前期开发时没有经过充分思考，很有可能会在后期优化时付出惨痛的代价。在这个项目中，我们的优化工作还远远不够，后续有更多突破会分享给大家。zh 参考资料[1]Electron: https://www.electronjs.org/[2]Electron Fiddle: https://www.electronjs.org/fiddle[3]脚手架: https://github.com/search?q=electron+boilerplate&amp;ref=opensearch[4]NW.js: https://nwjs.io/[5]electron-react-typescript: https://github.com/Robinfr/electron-react-typescript[6]src/main/main.ts: https://github.com/Robinfr/electron-react-typescript/blob/b50263f06ecd518bfd43421a3c0bc3c3be308b64/src/main/main.ts[7]src/renderer/app.tsx: https://github.com/Robinfr/electron-react-typescript/blob/b50263f06ecd518bfd43421a3c0bc3c3be308b64/src/renderer/app.tsx#L1[8]Devtron: https://www.electronjs.org/devtron[9]How Atom Uses Chromium Snapshots: https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/","pubDate":"Tue, 07 Apr 2020 09:00:00 GMT","guid":"https://aotu.io/notes/2020/04/07/electron-in-taro-ide/","category":"Web开发"},{"title":"如何打造高性能小程序门户","link":"https://aotu.io/notes/2020/03/25/high-performance-miniprogram/","description":"本文阅读时长约15分钟。京喜小程序开发团队核心成员倾力之作，都是干货，读完一定会收获满满，请大家耐心阅读～ 背景京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。 首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。 除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 Taro 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。 怎么定义高性能？提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。 谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关： 体验 指标 页面能否正常访问？ 首次内容绘制 (First Contentful Paint, FCP) 页面内容是否有用？ 首次有效绘制 (First Meaningful Paint, FMP) 页面功能是否可用？ 可交互时间 (Time to Interactive, TTI) 其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 FMP 是一个比较模糊的概念指标，不存在规范化的数值衡量。 小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为： FCP：白屏加载结束； FMP：首屏渲染完成； TTI：所有内容加载完成； 综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。 小程序官方性能指标小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现、setData 数据量、元素节点数 和 网络请求延时 这几个维度来给予定义（下面只列出部分关键指标）： 首屏时间不超过 5 秒； 渲染时间不超过 500ms； 每秒调用 setData 的次数不超过 20 次； setData 的数据在 JSON.stringify 后不超过 256kb； 页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个； 所有网络请求都在 1 秒内返回结果； 详见 小程序性能评分规则 我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。 我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求： 首屏时间不超过 2.5 秒； setData 的数据量不超过 100kb； 所有网络请求都在 1 秒内返回结果； 组件滑动、长列表滚动无卡顿感； 体验评分工具小程序提供了 体验评分工具（Audits 面板） 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。 以上截图均来自小程序官方文档 体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。 小程序后台性能分析我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧，小程序管理平台 和 小程序助手 为开发者提供了大量的真实数据统计。其中，性能分析面板从 启动性能、运行性能 和 网络性能 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。 其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时 第三方测速系统很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 页面 onLoad、onReady、数据加载完成、首屏渲染完成、各业务组件首次渲染完成 等几个关键节点统计测速上报，旨在全链路监控性能表现。 另外，微信为开发者提供了 测速系统，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。 了解小程序底层架构为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。 微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。 而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了双线程模型： 视图层：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面； 逻辑层：一个单独的线程执行 JS 代码，可以控制视图层的逻辑； 上图来自小程序官方开发指南 然而，任何线程间的数据传输都是有延时的，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。 作为小程序开发者，我们常常会被下面几个问题所困扰： 小程序启动慢； 白屏时间长； 页面渲染慢； 运行内存不足； 接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。 小程序启动太慢？小程序启动阶段，也就是如下图所示的展示加载界面的阶段。 在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作： 1. 准备运行环境： 在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。 小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。 2. 下载小程序代码包： 在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。 3. 加载小程序代码包： 小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。 在此阶段，主包内的所有页面 JS 文件及其依赖文件都会被自动执行。 在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。 4. 初始化小程序首页： 在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。 综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 控制代码包大小，缩小代码包的下载时间。 无用文件、函数、样式剔除经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。 因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。 文件依赖分析 在小程序中，所有页面的路径都需要在小程序代码根目录 app.json 中被声明，类似地，自定义组件也需要在页面配置文件 page.json 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。 WXML 中的 import 和 include： 12345678&lt;!-- A.wxml --&gt;&lt;template name='A'&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt;&lt;!-- B.wxml --&gt;&lt;import src=\"A.wxml\"/&gt;&lt;template is=\"A\" data=\"&#123;&#123;text: 'B'&#125;&#125;\"/&gt; 123456&lt;!-- A.wxml --&gt;&lt;text&gt; A &lt;/text&gt;&lt;!-- B.wxml --&gt;&lt;include src=\"A.wxml\"/&gt;&lt;text&gt; B &lt;/text&gt; WXSS 中的 @import： 1@import './A.wxss' JS 中的 require/import： 1const A = require('./A') 所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。 JS、CSS Tree-Shaking JS Tree-Shaking 的原理就是借助 Babel 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。 而 CSS 的 Tree-Shaking 可以利用 PurifyCSS 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。 题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享：小程序工程化探索。 减少代码包中的静态资源文件小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 JPG、PNG 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。 需要注意，Base64 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。 逻辑后移，精简业务逻辑这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了…（开个玩笑） 通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。 总结得出，一般不涉及前端计算的展示类逻辑，都可以适当做后移。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的： 123456789101112131415161718192021// 检查每种弹窗类型是否已展示Promise.all([ check(popup_1), check(popup_2), // ... check(popup_n)]).then(result =&gt; &#123; // 优先级排序 const queue = [&#123; show: result.popup_1 data: data.popup_1 &#125;, &#123; show: result.popup_2 data: data.popup_2 &#125;, // ... &#123; show: result.popup_n data: data.popup_n &#125;]&#125;) 逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样： 123this.setData(&#123; popup: data.popup&#125;) 复用模板插件京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。 类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具，我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素）。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 if / else 逻辑，so easy～ 当然，要完成这样的插件化改造免不了几个先决条件： 用户体验设计的统一。如果设计风格总是天差地别的，强行插件化只会成为累赘。 服务端接口的统一。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。 下面为大家提供部分例程来辅助理解。其中，use 方法会接受各类处理钩子最终拼接出一个 Function，在对应模块处理数据时会被调用。 1234567891011121314151617181920212223242526272829303132333435// bi.helper.js/** * 插件引擎 * @param &#123;function&#125; options.formatName 标题处理钩子 * @param &#123;function&#125; options.validList 数据校验器钩子 */ const use = options =&gt; data =&gt; format(data)/** * 预置插件库 */ nameHelpers = &#123; text: data =&gt; data.text, icon: data =&gt; data.icon&#125;listHelpers = &#123; single: list =&gt; list.slice(0, 1), double: list =&gt; list.slice(0, 2)&#125;/** * “堆积木” */export default &#123; 1000: use(&#123; formatName: nameHelpers.text, validList: listHelpers.single &#125;), 1001: use(&#123; formatName: nameHelpers.icon, validList: listHelpers.double &#125;)&#125; 12345678910&lt;!-- bi.wxml --&gt;&lt;!-- 各模板节点实现 --&gt;&lt;template name=\"renderName\"&gt; &lt;view wx:if=\"&#123;&#123;type === 'text'&#125;&#125;\"&gt; text &lt;/view&gt; &lt;view wx:elif=\"&#123;&#123;type === 'icon'&#125;&#125;\"&gt; icon &lt;/view&gt;&lt;/template&gt;&lt;view class=\"bi__name\"&gt; &lt;template is=\"renderName\" data=\"&#123;&#123;...data.name&#125;\"/&gt;&lt;/view&gt; 12345678910// bi.jsComponent(&#123; ready() &#123; // 根据 tpl 值选择解析函数 const formatData = helper[data.tpl] this.setData(&#123; data: formatData(data) &#125;) &#125;&#125;) 分包加载小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档： 使用分包 独立分包 部分页面 h5 化小程序提供了 web-view 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。 小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 小程序开发文档。 白屏时间过长？白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。 FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成： 网络资源加载时间； 渲染时间； 启用本地缓存小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。 但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。 小程序默认会按照 不同小程序、不同微信用户 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 数据版本号、用户属性 来对缓存进行再隔离，避免信息误展示。 数据预拉取小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力：数据预拉取。 关于冷启动和热启动的定义可以看 这里 数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。 京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方： 预拉取的数据会被强缓存； 由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。 请求体和响应体都无法被拦截； 由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。 小程序内部接口的响应体类型都是 application/octet-stream，即数据格式未知，使本地代理无法正确解析。 微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息； 如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。 跳转时预拉取为了尽快获取到服务端数据，比较常见的做法是在页面 onLoad 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 onLoad 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。 实际上，我们可以在发起跳转前（如 wx.navigateTo 调用前），提前请求下一个页面的主接口并存储在全局 Promise 对象中，待下个页面加载完成后从 Promise 对象中读取数据即可。 这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。 分包预下载如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。 幸好，小程序提供了 分包预下载 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。 非关键渲染数据延迟请求这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。 关键渲染路径（Critical Rendering Path） 是指在完成首屏渲染的过程中必须发生的事件。 以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类：主体模块（导航、商品轮播、商品豆腐块等）和 非主体模块（幕帘弹窗、右侧挂件等）。 在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。 分屏渲染这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。 类似上一条措施，继续以京喜小程序首页为例，我们在 主体模块 的基础上再度划分出 首屏模块（商品豆腐块以上部分） 和 非首屏模块（商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。 为了更好地呈现效果，上面 gif 做了降速处理 接口聚合，请求合并在小程序中，发起网络请求是通过 wx.request 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用： wx.request （HTTP 连接）的最大并发限制是 10 个； wx.connectSocket （WebSocket 连接）的最大并发限制是 5 个； 超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此，对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。 图片资源优化图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。 使用 WebP 格式 WebP 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。 小程序的 image 组件 支持 JPG、PNG、SVG、WEBP、GIF 等格式。 图片裁剪&amp;降质 鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片： 裁剪成 100x100 的图片：https://{host}/s100x100_jfs/{file_path}； 降质 70%：https://{href}!q70； 图片懒加载、雪碧图（CSS Sprite）优化 这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。 小程序的 image 组件 自带 lazy-load 懒加载支持。雪碧图技术（CSS Sprite）可以参考 w3schools 的教程。 降级加载大图资源 在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。 小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源，我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 &lt;image&gt; 节点来加载原图，待原图加载完成后再转移到真实节点上渲染。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。 下面为大家提供部分例程： 12345678910&lt;!-- banner.wxml --&gt;&lt;image src=\"&#123;&#123;url&#125;&#125;\" /&gt;&lt;!-- 图片加载器 --&gt;&lt;image style=\"width:0;height:0;display:none\" src=\"&#123;&#123;preloadUrl&#125;&#125;\" bindload=\"onImgLoad\" binderror=\"onErrorLoad\"/&gt; 1234567891011121314151617// banner.jsComponent(&#123; ready() &#123; this.originUrl = 'https://path/to/picture' // 图片源地址 this.setData(&#123; url: compress(this.originUrl) // 加载压缩降质的图片 preloadUrl: this.originUrl // 预加载原图 &#125;) &#125;, methods: &#123; onImgLoad() &#123; this.setData(&#123; url: this.originUrl // 加载原图 &#125;) &#125; &#125;&#125;) 注意，具有 display: none 样式的 &lt;image&gt; 标签只会加载图片资源，但不渲染。 京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。 为了更好地呈现效果，上面 gif 做了降速处理 骨架屏一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。 “白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。 骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。 有趣的是，京喜首页的骨架屏方案经历了 “统一管理” 和 “（组件）独立管理” 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的： 12345&lt;!-- index.wxml --&gt;&lt;skeleton wx:if=\"&#123;&#123;isLoading&#125;&#125;\"&gt;&lt;/skeleton&gt;&lt;block wx:else&gt; 页面主体&lt;/block&gt; 但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。 为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 sass 模块集中管理，业务组件只需要在适当的节点挂上 skeleton 和 skeleton__block 样式块即可，极大地降低了维护成本。 1234&lt;!-- banner.wxml --&gt;&lt;view class=\"&#123;&#123;isLoading ? 'banner--skeleton' : ''&#125;&#125;\"&gt; &lt;view class=\"banner_wrapper\"&gt;&lt;/view&gt;&lt;/view&gt; 1234567// banner.scss.banner--skeleton &#123; @include skeleton; .banner_wrapper &#123; @include skeleton__block; &#125;&#125; 上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。 如何提升渲染性能？当调用 wx.navigateTo 打开一个新的小程序页面时，小程序框架会完成这几步工作： 1. 准备新的 webview 线程环境，包括基础库的初始化； 2. 从逻辑层到视图层的初始数据通信； 3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染； 由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信 和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是： 降低线程间通信频次； 减少线程间通信的数据量； 减少 WXML 节点数量； 合并 setData 调用尽可能地把多次 setData 调用合并成一次。 我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 setData 的调用频次。譬如，把同一个时间片（事件循环）内的 setData 调用合并在一起，Taro 框架就使用了这个优化手段。 在 Taro 框架下，调用 setState 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 setData 传递给原生小程序。 12// 小程序里的时间片 APIconst nextTick = wx.nextTick ? wx.nextTick : setTimeout; 只把与界面渲染相关的数据放在 data 中不难得出，setData 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系： 上图来自小程序官方开发指南 所以，与视图层渲染无关的数据尽量不要放在 data 中，可以放在页面（组件）类的其他字段下。 应用层的数据 diff每当调用 setData 更新数据时，会引起视图层的重新渲染，小程序会结合新的 data 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。 即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 setData 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。 Taro 框架内部做了这一层优化。在每次调用原生小程序的 setData 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 setData。 附 Taro 框架的 数据 diff 规则 去掉不必要的事件绑定当用户事件（如 Click、Touch 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。 所以，尽量减少不必要的事件绑定，尤其是像 onPageScroll 这种会被频繁触发的用户事件，会使通信过程频繁发生。 去掉不必要的节点属性组件节点支持附加自定义数据 dataset（见下面例子），当用户事件被触发时，视图层会把事件 target 和 dataset 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。 12345678&lt;!-- wxml --&gt;&lt;view data-a='A' data-b='B' bindtap='bindViewTap'&gt; Click Me!&lt;/view&gt; 123456// jsPage(&#123; bindViewTap(e) &#123; console.log(e.currentTarget.dataset) &#125;&#125;) 适当的组件颗粒度小程序的组件模型与 Web Components 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、setData 调用、createSelectorQuery 执行域等）。 不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 setData 的性能。另外，如果组件内使用了 createSelectorQuery 来查找节点，过于庞大的节点树结构也会影响查找效率。 我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 setInterval 每秒调用 setData 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 setData 时的性能影响。 适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智… 事件总线，替代组件间数据绑定的通信方式WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示：Component A 组件中的变量 a、b 通过组件属性传递给 Component B 组件。在此过程中，不可避免地需要经历一次 Component A 组件的 setData 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？ 12&lt;!-- Component A --&gt;&lt;component-b prop-a=\"&#123;&#123;a&#125;&#125;\" prop-b=\"&#123;&#123;b&#125;&#125;\" /&gt; 12345678910111213// Component BComponent(&#123; properties: &#123; propA: String, propB: String, &#125;, methods: &#123; onLoad: function() &#123; this.data.propA this.data.propB &#125; &#125;&#125;) 推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码…）： 一个全局的事件调度中心 1234567891011121314151617class EventBus &#123; constructor() &#123; this.events = &#123;&#125; &#125; on(key, cb) &#123; this.events[key].push(cb) &#125; trigger(key, args) &#123; this.events[key].forEach(function (cb) &#123; cb.call(this, ...args) &#125;) &#125; remove() &#123;&#125;&#125;const event = new EventBus() 事件订阅者 123456// 子组件Component(&#123; created() &#123; event.on('data-ready', (data) =&gt; &#123; this.setData(&#123; data &#125;) &#125;) &#125;&#125;) 事件发布者 123456// ParentComponent(&#123; ready() &#123; event.trigger('data-ready', data) &#125;&#125;) 子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。 但并非所有场景都适合这种做法。像京喜首页这种具有 “数据单向传递”、“展示型交互” 特性、且 一级子组件数量庞大 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。 题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 Object.defineProperty 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。 组件层面的 diff我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。 京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了…）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 &lt;template&gt;。 实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。 123456789101112131415&lt;!-- index.wxml --&gt;&lt;template name=\"render-component\"&gt; &lt;search-bar wx:if=\"&#123;&#123;compId === 'SearchBar'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt; &lt;nav-bar wx:if=\"&#123;&#123;compId === 'NavBar'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt; &lt;banner wx:if=\"&#123;&#123;compId === 'Banner'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt; &lt;icon-nav wx:if=\"&#123;&#123;compId === 'IconNav'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt;&lt;/template&gt;&lt;view class=\"component-wrapper\" wx:for=\"&#123;&#123;comps&#125;&#125;\" wx:for-item=\"comp\"&gt; &lt;template is=\"render-component\" data=\"&#123;&#123;...comp&#125;&#125;\"/&gt;&lt;/view&gt; 1234567891011// search-bar.jsComponent(&#123; properties: &#123; floorId: Number, &#125;, created() &#123; event.on('data-ready', (comps) =&gt; &#123; const data = comps[this.data.floorId] // 根据楼层位置取数据 &#125;) &#125;&#125;) 貌似非常轻松地完成需求，但值得思考的是：如果组件顺序调整了，所有组件的生命周期会发生什么变化？ 假设，上一次渲染的组件顺序是 [&#39;search-bar&#39;，&#39;nav-bar&#39;，&#39;banner&#39;, &#39;icon-nav&#39;]，现在需要把 nav-bar 组件去掉，调整为 [&#39;search-bar&#39;，&#39;banner&#39;, &#39;icon-nav&#39;]。经实验得出，当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。 原理很简单，每个组件都有各自隔离的节点树（ShadowTree），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 nav-bar 组件节点不见了，就认为该（树）分支下从 nav-bar 节点起发生了变化，往后节点都需要重渲染。 但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 setData 前先进行了新旧组件列表 diff：如果 newList 里面的组件是 oldList 的子集，且相对顺序没有发生变化，则所有组件不重新挂载。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。 通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。 内存占用过高？想必没有什么会比小程序 Crash 更影响用户体验了。 当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。 内存预警小程序提供了监听内存不足告警事件的 API：wx.onMemoryWarning，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 wx.reLaunch 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好…）。 不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。 回收后台页面计时器根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 setInterval、setTimeout 定时器： 1234567// Page APage(&#123; onLoad() &#123; let i = 0 setInterval(() =&gt; &#123; i++ &#125;, 100) &#125;&#125;) 即使如小程序的 &lt;swiper&gt; 组件，在页面进入后台态时依然是会持续轮播的。 正确的做法是，在页面 onHide 的时候手动把定时器清理掉，有必要时再在 onShow 阶段恢复定时器。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 setData 大量数据，这就非常难受了… 避免频发事件中的重度内存操作我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 onPageScroll 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 setData 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则： onPageScroll 事件回调使用节流； 避免 CPU 密集型操作，譬如复杂的计算； 避免调用 setData，或减小 setData 的数据量； 尽量使用 IntersectionObserver 来替代 SelectorQuery，前者对性能影响更小； 大图、长列表优化据 小程序官方文档 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。 对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。 对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。 然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。 小程序官方提供了一个 长列表组件，可以通过 npm 包的方式引入，有兴趣的可以尝试。 总结结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷： 1. Audits 审计工具的性能得分 86； 2. 优化后的首屏渲染完成时间（FMP）： 3. 优化前后的测速数据对比： 然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。 参考 User-centric Performance Metrics Reduce JavaScript Payloads with Tree Shaking 小程序开发指南 小程序官方文档 Taro 官方文档 探究WebP一些事儿 京喜首页（微信购物入口）跨端开发与优化实践","pubDate":"Wed, 25 Mar 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/03/25/high-performance-miniprogram/","category":"性能优化"},{"title":"直播回顾·程序媛的成长蜕变","link":"https://aotu.io/notes/2020/03/17/technological-growth/","description":"在平平淡淡的工作中，突然要准备一个直播分享，犹如平地一声雷。预知雷声大不大，请看下文&amp;视频完整版：B站回播地址、牛客网录播地址。 本次分享由腾讯犀牛鸟「云开发」校园技术布道师养成计划邀请，为年轻程序员解答，如何进入学习提升自己、如何找到最适合自己的技术路线以及如何才能在毕业后进入大厂等问题。 本文从两个模块展开，首先分享从小白时期成长为高级工程师的成长历程，然后探讨程序员应该从哪些方面着手，提升自身的技术实力。 一、成长历程分享我的成长历程大致分为 3 个阶段，重构开发阶段、前端开发阶段，然后到全栈开发。 重构开发2015 年处于重构开发阶段。 当时作为一个硬件转软件的大三实习生，实习工作前只学习了一个月前端相关的知识，基础薄弱，一开始每天的工作就是 HTML + CSS 写静态页面，或者就是直接扒网站，改改样式和文案。在项目前后端分离后，才开始做动画和交互的开发工作。 前端开发2016 - 2018 处于前端开发阶段。 2016 年是特别好找工作的一年，投简历有大把的面试，会 HTML + CSS + jQuery + 有项目经验就可以当一个初级的前端开发。在日常工作之余，每周会定一些任务看哪本书，看哪个技术的文档，也开始写技术博客。在工作中，参与开发公司的官网系统，在这个项目的参与过程中，前端构建工具 fis3、css 预编译工具 Sass，当时很流行的 CSS / HTML 框架 Bootstrap，模板引擎 ejs，这些技术都有了实战经验。后来又参与开发员工管理系统，在这个系统中开始用 Angular 搭建项目，有了这些积累，2017 年终于成为了中级前端开发。 初级和中级的不同，更多的差异是在于责任心的比重，初级一般只负责单一模块的开发，中级除了模块的开发，还需要更多承担起项目某一条业务线的管理职责。 技术发展得非常快，前端框架方面，Vue、React 对比 Angular 有更好的性能，Angular 也出到更高的版本，前端构建工具方面，Webpack 对比 fis3，开发更加便捷，扩展性强，在技术新趋势方面，还有小程序业务也越来越多，我也跟着继续学习新技术，根据项目场景进行运用。 题图引用自利用NLP分析三大前端框架的GitHub Issue 全栈开发2019 - 2020 处于全栈开发阶段。 在前端开发的过程中，我也一直想往全栈的方向走，学习 Python、Nodejs、MongoDB、Nginx，有了这些积累，我开始负责全栈项目，在职级上成为了高级前端开发工程师。 在这个过程中，我也从一开始的仅仅为了就业，到喜欢上这份工作，发现编程其实没有我想象中那么难和枯燥，相反，在编程的过程中，解决问题和实现需求都是非常有成就感的一件事情。 和大多数初学者一样，刚开始的时候我非常迷茫，没有做好职业规划就匆匆开始了实习。但是，我的建议是如果你没有想好自己要干什么，一定要先把眼前的事情做好。 二、如何提升技术实力如何提升技术实力，建议先做好这3点：注重基础、实践练习、在过程中多多思考。 基础首先，就我个人经历而言，我认为初学者应该特别注意这个点，要注重基础，应该不能急于求成，欲速则不达，要想快速提高，必须要以慢打快，才能更快。因为对于初学者而言，基础知识，编程语言必须要夯实，只有真正的懂了基础，才能够举一反三。 那么如何学习好基础呢？ 1. 视频教程网上有很多，我在初学阶段也是看的视频教程进行学习，但是但是这种学习方式效率比较低，一个 30 分钟的视频教程讲解的内容，如果是直接看书的话至少可以节省一半时间。不过初学阶段是可以看视频的，有老师讲解会比单看书看文档更加有趣。建议直接在网上搜上一套完整的教学视频，系统的去学。 2. 入门博客在各大论坛网站上去找或者直接百度搜，前端的同学推荐 阮一峰大神的博客、知乎专栏、凹凸官网，看博客对学习也是非常有帮助的。 3. 权威书籍如果想要把基础学扎实，还是推荐看书，尤其是权威书籍，因为书里不会遗漏重点，能提高对技术认知的深度，比如看入门博客，其实这是接受博主的二次传播，博主讲的是他对书对技术的理解，他的理解肯定没有写书的人的理解深，说不定还会遗漏一些重点。所以还不如直接看书。 比如前端的话就一定要去看 JavaScript 高级程序设计、或者 JavaScript 权威指南，这两本书都是学习前端的基石。JavaScript 高级程序设计我就看了很多遍，每一遍都会有新的收获，建议你们也把权威书籍多看几遍，看多了就知道原理了，而不是单单知道怎么敲代码实现。 4. 官方文档一定要学会怎么去看文档，开发的过程中肯定会遇到很多的问题，学会了看文档就可以提高自己解决问题的能力，也可以提高学习新技术的能力。 实践在学习基础知识的同时，也要实践练习。可以从下面 3 个方面着手。 1. 局部练习首先我们要做一些局部练习，比如小型实战、环境搭建、学习时遇到的例子，可以挑一个去实际做一下运行，因为有些东西你可能看的很模糊，这时候你必须得敲一点代码，实际的运行，看看效果，才能真正的理解，并且在实战中才能遇到问题，在解决问题的过程中才是真正的掌握这门技术，实战的过程中要及时记录遇到的问题和如何解决的，长远来看对自己的成长是非常有帮助的。 2. 上手实际项目做了一些小型实战之后，就是上手实际的项目，在实际项目中，可以真正的运用学到的知识，也可以找到自己不足的地方，有很多人不知道自己不知道哪些，做做项目就都知道了。很多在校的学生在学习过程中没有实际项目，没有关系，我们也可以从开源项目着手，从开源项目的源码的学习，是一种最高级的学习方式，也是最高效最能学到东西的，这种开源的学习方式。有个前提，就是前面基础要打牢固，包括计算机网络和数据结构的知识，这都是有能力去玩一个开源项目的基本素质。 3. 造轮子、撸源码学习到更深一层的时候，可以造轮子、出一些源码阅读的文章，或者视频，还可以把东西分享给别人，写一些深度的博客。让大家来参考。这一步是确实比较难达到，我自己也在不断的摸索中。 思考在这里还要再强调一遍学习最关键的一步，就是思考。 1. 学会记录学习的时候，要学会记录总结。在学习的过程中，老师讲的 demo，总结的知识点，自己记录到技术博客中，编程知识点太多，烂熟于心是不可能的，那就不如写博客记录下来。写在博客中，既能分享，又能方便自己查找，还能巩固自己的知识点。而且在博客积累的过程中，也能够为你累积流量，建立自己的 IP，这对找工作也是非常有帮助的。 2. 找到你的导师对于初学者来说还有一点非常重要，那就是给自己找一个老师，每个人都需要一个职场的导师，他可以是你第一份工作的导师，也可以是你认识的其他的前辈。你们需要维系一个非常长期的关系，不止于一家公司，最好贯穿你的整个职业生涯。每当你遇到疑惑的时候，都可以询求他的建议，这将是你最宝贵的一笔人脉财富。我在入行不久也遇到了这样一个老师，他会问我学得怎么样，给我目标，而且还给我开过一对一的课，当然他开课也是因为他自己想往教育这个方向去发展，但是不得不说对我的帮助非常大，我非常感激他。他也和我说过，他的导师对他的影响也很大。 每个人都明白人脉的重要性，但实际做起来却不容易。建议参加一些线下的活动，比如各个开发者大会或者沙龙，这可能是最直接的扩展人脉的方式之一。 三、总结本文分享了程序员的个人成长历程以及如何提升技术实力，程序员的成长之路并不孤单，我们是一个爱分享的群体，也有非常多的社区，看到这里的你，想必已经进入我们这个大社区了，希望本文能给你收获，在技术之路一起成长！","pubDate":"Tue, 17 Mar 2020 10:24:00 GMT","guid":"https://aotu.io/notes/2020/03/17/technological-growth/","category":"Web开发"},{"title":"Web 中文字体处理总结","link":"https://aotu.io/notes/2020/02/28/webfont-processing/","description":"背景介绍Web 项目中，使用一个合适的字体能给用户带来良好的体验。但是字体文件太多，如果想要查看字体效果，只能一个个打开，非常影响工作效率。因此，需要实现一个功能，能够根据固定文字以及用户输入预览字体。在实现这一功能的过程中主要解决两个问题： 中文字体体积太大导致加载时间过长 字体加载完成前不展示预览内容 现在将问题的解决以及我的思考总结成文。 使用 web 自定义字体在聊这两个问题之前，我们先简述怎样使用一个 Web 自定义字体。要想使用一个自定义字体，可以依赖 CSS Fonts Module Level 3 定义的 @font-face 规则。一种基本能够兼容所有浏览器的使用方法如下： 12345678910111213@font-face &#123; font-family: \"webfontFamily\"; /* 名字任意取 */ src: url('webfont.eot'); url('web.eot?#iefix') format(\"embedded-opentype\"), url(\"webfont.woff2\") format(\"woff2\"), url(\"webfont.woff\") format(\"woff\"), url(\"webfont.ttf\") format(\"truetype\"); font-style:normal; font-weight:normal;&#125;.webfont &#123; font-family: webfontFamily; /* @font-face里定义的名字 */&#125; 由于 woff2、woff、ttf 格式在大多数浏览器支持已经较好，因此上面的代码也可以写成： 12345678@font-face &#123; font-family: \"webfontFamily\"; /* 名字任意取 */ src: url(\"webfont.woff2\") format(\"woff2\"), url(\"webfont.woff\") format(\"woff\"), url(\"webfont.ttf\") format(\"truetype\"); font-style:normal; font-weight:normal;&#125; 有了@font-face 规则，我们只需要将字体源文件上传至 cdn，让 @font-face 规则的 url 值为该字体的地址，最后将这个规则应用在 Web 文字上，就可以实现字体的预览效果。 但这么做我们可以明显发现一个问题，字体体积太大导致的加载时间过长。我们打开浏览器的 Network 面板查看： 可以看到字体的体积为5.5 MB，加载时间为5.13 s。而夸克平台很多的中文字体大小在20～40 MB 之间，可以预想到加载时间会进一步增长。如果用户还处于弱网环境下，这个等待时间是不能接受的。 一、中文字体体积太大导致加载时间过长1. 分析原因那么中文字体相较于英文字体体积为什么这么大，这主要是两个方面的原因： 中文字体包含的字形数量很多，而英文字体仅包含26个字母以及一些其他符号。 中文字形的线条远比英文字形的线条复杂，用于控制中文字形线条的位置点比英文字形更多，因此数据量更大。 我们可以借助于 opentype.js，统计一个中文字体和一个英文字体在字形数量以及字形所占字节数的差异: 字体名称 字形数 字形所占字节数 FZQingFSJW_Cu.ttf 8731 4762272 JDZhengHT-Bold.ttf 122 18328 夸克平台字体预览需要满足两种方式，一种是固定字符预览, 另一种是根据用户输入的字符进行预览。但无论哪种预览方式，也仅仅会使用到该字体的少量字符，因此全量加载字体是没有必要的，所以我们需要对字体文件做精简。 2. 如何减小字体文件体积unicode-rangeunicode-range 属性一般配合 @font-face 规则使用，它用于控制特定字符使用特定字体。但是它并不能减小字体文件的大小，感兴趣的读者可以试试。 CSS unicode-range特定字符使用font-face自定义字体 fontminfontmin 是一个纯 JavaScript 实现的字体子集化方案。前文谈到，中文字体体积相较于英文字体更大的原因是其字形数量更多，那么精简一个字体文件的思路就是将无用的字形移除： 1234567// 伪代码const text = '字体预览'const unicodes = text.split('').map(str =&gt; str.charCodeAt(0))const font = loadFont(fontPath)font.glyf = font.glyf.map(g =&gt; &#123; // 根据unicodes获取对应的字形&#125;) 实际上的精简并没有这么简单，因为一个字体文件由许多表(table)构成，这些表之间是存在关联的，例如 maxp 表记录了字形数量，loca 表中存储了字形位置的偏移量。同时字体文件以 offset table(偏移表) 开头，offset table记录了字体所有表的信息，因此如果我们更改了 glyf 表，就要同时去更新其他表。 在讨论 fontmin 如何进行字体截取之前，我们先来了解一下字体文件的结构： 上面的结构限于字体文件只包含一种字体，且字形轮廓是基于 TrueType 格式（决定 sfntVersion 的取值）的情况，因此偏移表会从字体文件的0字节开始。如果字体文件包含多个字体，则每种字体的偏移表会在 TTCHeader 中指定，这种文件不在文章的讨论范围内。 偏移表(offset table)： Type Name Description uint32 sfntVersion 0x00010000 uint16 numTables Number of tables uint16 searchRange (Maximum power of 2 &lt;= numTables) x 16. uint16 entrySelector Log2(maximum power of 2 &lt;= numTables). uint16 rangeShift NumTables x 16-searchRange. 表记录(table record)： Type Name Description uint32 tableTag Table identifier uint32 checkSum CheckSum for this table uint32 offset Offset from beginning of TrueType font file uint32 length Length of this table 对于一个字体文件，无论其字形轮廓是 TrueType 格式还是基于 PostScript 语言的 CFF 格式，其必须包含的表有 cmap、head、hhea、htmx、maxp、name、OS/2、post。如果其字形轮廓是 TrueType 格式，还有cvt、fpgm、glyf、loca、prep、gasp 六张表会被用到。这六张表除了 glyf 和 loca 必选外，其它四个为可选表。 fontmin 截取字形原理fontmin 内部使用了 fonteditor-core，核心的字体处理交给这个依赖完成，fonteditor-core 的主要流程如下： 1. 初始化 Reader将字体文件转为 ArrayBuffer 用于后续读取数据。 2. 提取 Table Directory前文我们说到紧跟在 offset table(偏移表) 之后的结构就是 table record(表记录)，而多个 table record 叫做 Table Directory。fonteditor-core 会先读取原字体的 Table Directory，由上文表记录的结构我们知道，每一个 table record 有四个字段，每个字段占4个字节，因此可以很方便的利用 DataView 进行读取，最终得到一个字体文件的所有表信息如下： 3. 读取表数据在这一步会根据 Table Directory 记录的偏移和长度信息读取表数据。对于精简字体来说，glyf 表的内容是最重要的，但是 glyf 的 table record 仅仅告诉了我们 glyf 表的长度以及 glyf 表相对于整个字体文件的偏移量，那么我们如何得知 glyf 表中字形的数量、位置以及大小信息呢？这需要借助字体中的 maxp 表和 loca(glyphs location) 表，maxp 表的 numGlyphs 字段值指定了字形数量，而 loca 表记录了字体中所有字形相对于 glyf 表的偏移量，它的结构如下： Glyph Index Offset Glyph Length 0 0 100 1 100 150 2 250 0 … … … n-1 1170 120 extra 1290 0 根据规范，索引0指向缺失字符(missing character)，也就是字体中找不到某个字符时出现的字符，这个字符通常用空白框或者空格表示，当这个缺失字符不存在轮廓时，根据 loca 表的定义可以得到 loca[n] = loca[n+1]。我们可以发现上文表格中多出了 extra 一项，这是为了计算最后一个字形 loca[n-1] 的长度。 上述表格中 Offset 字段值的单位是字节，但是具体的字节数取决于字体 head 表的 indexToLocFormat 字段取值，当此值为0时，Offset 100 等于 200 个字节，当此值为1时，Offset 100 等于 100 个字节，这两种不同的情况对应于字体中的 Short version 和 Long version。 但是仅仅知道所有字形的偏移量还不够，我们没办法认出哪个字形才是我们需要的。假设我需要字体预览这四个字形，而字体文件有一万个字形，同时我们通过 loca 表得知了所有字形的偏移量，但这一万里面哪四个数据块代表了字体预览四个字符呢？因此我们还需要借助 cmap 表来确定具体的字形位置，cmap 表里记录了字符代码(unicode)到字形索引的映射，我们拿到对应的字形索引后，就可以根据索引获得该字形在 glyf 表中的偏移量。 而一个字形的数据结构以 Glyph Headers 开头： Type Name Description int16 numberOfContours the number of contours int16 xMin Minimum x for coordinate data int16 yMin Maximum y for coordinate data int16 xMax Minimum x for coordinate data int16 yMax Maximum x for coordinate data numberOfContours 字段指定了这个字形的轮廓数量，紧跟在 Glyph Headers 后面的数据结构为 Glyph Table。 在字体的定义中，轮廓是由一个个位置点构成的，并且每个位置点具有编号，这些编号从0开始按升序排列。因此我们读取指定的字形就是读取 Glyph Headers 中的各项值以及轮廓的位置点坐标。 在 Glyph Table 中，存放了每个轮廓的最后一个位置点编号构成的数组，从这个数组中就可以求得这个字形一共存在几个位置点。例如这个数组的值为[3, 6, 9, 15]，可以得知第四个轮廓上最后一个位置点的编号是15，那么这个字形一共有16个位置点，所以我们只需要以16为循环次数进行遍历访问 ArrayBuffer 就可以得到每个位置点的坐标信息，从而提取出了我们想要的字形，这也就是 fontmin 在截取字形时的原理。 另外，在提取坐标信息时，除了第一个位置点，其他位置点的坐标值并不是绝对值，例如第一个点的坐标为[100, 100]，第二个读取到的值为[200, 200]，那么该点位置坐标并不是[200, 200]，而是基于第一个点的坐标进行增量，因此第二点的实际坐标为[300, 300] 因为一个字体涉及的表实在太多，并且每个表的数据结构也不一样。这里无法一一列举 fonteditor-core 是如何处理每个表的。 4. 关联glyf信息在使用了 TrueType 轮廓的字体中，每个字形都提供了 xMin、xMax、yMin 和 yMax 的值，这四个值也就是下图的Bounding Box。除了这四个值，还需要 advanceWidth 和 leftSideBearing 两个字段，这两个字段并不在 glyf 表中，因此在截取字形信息的时候无法获取。在这个步骤，fonteditor-core 会读取字体的 hmtx 表获取这两个字段。 5. 写入字体在这一步会重新计算字体文件的大小，并且更新偏移表(Offset table)和表记录(Table record)有关的值, 然后依次将偏移表、表记录、表数据写入文件中。有一点需要注意的是，在写入表记录时，必须按照表名排序进行写入。例如有四张表分别是 prep、hmtx、glyf、head、则写入的顺序应为 glyf -&gt; head -&gt; hmtx -&gt; prep，而表数据没有这个要求。 fontmin 不足之处fonteditor-core 在截取字体的过程中只会对前文提到的十四张表进行处理，其余表丢弃。每个字体通常还会包含 vhea 和 vmtx 两张表，它们用于控制字体在垂直布局时的间距等信息，如果用 fontmin 进行字体截取后，会丢失这部分信息，可以在文本垂直显示时看出差异（右边为截取后）： fontmin 使用方法在了解了 fontmin 的原理后，我们就可以愉快的使用它啦。服务器接受到客户端发来的请求后，通过 fontmin 截取字体，fontmin 会返回截取后的字体文件对应的 Buffer，别忘了 @font-face 规则中字体路径是支持 base64 格式的，因此我们只需要将 Buffer 转为 base64 格式嵌入在 @font-face 中返回给客户端，然后客户端将该 @font-face 以 CSS 形式插入 &lt;head&gt;&lt;/head&gt; 标签中即可。 对于固定的预览内容，我们也可以先生成字体文件保存在 CDN 上，但是这个方式的缺点在于如果 CDN 不稳定就会造成字体加载失败。如果用上面的方法，每一个截取后的字体以 base64 字符串形式存在，则可以在服务端做一个缓存，就没有这个问题。利用 fontmin 生成字体子集代码如下： 123456789101112131415const Fontmin = require('fontmin')const Promise = require('bluebird')async function extractFontData (fontPath) &#123; const fontmin = new Fontmin() .src('./font/senty.ttf') .use(Fontmin.glyph(&#123; text: '字体预览' &#125;)) .use(Fontmin.ttf2woff2()) .dest('./dist') await Promise.promisify(fontmin.run, &#123; context: fontmin &#125;)()&#125;extractFontData() 对于固定预览内容我们可以预先生成好分割后的字体，对于用户输入的动态预览内容，我们当然也可以按照这个流程： 获取输入 -&gt; 截取字形 -&gt; 上传 CDN -&gt; 生成 @font-face -&gt; 插入页面 按照这个流程来客户端需要请求两次才能获取字体资源（别忘了在 @font-face 插入页面后才会去真正请求字体），并且截取字形和上传 CDN 这两步时间消耗也比较长，有没有更好的办法呢？我们知道字形的轮廓是由一系列位置点确定的，因此我们可以获取 glyf 表中的位置点坐标，通过 SVG 图像将特定字形直接绘制出来。 SVG 是一种强大的图像格式，可以使用 CSS 和 JavaScript 与它们进行交互，在这里主要应用了 path 元素 获取位置信息以及生成 path 标签我们可以借助 opentype.js 完成，客户端得到输入字形的 path 元素后，只需要遍历生成 SVG 标签即可。 3. 减小字体文件体积的优势下面附上字体截取后文件大小和加载速度对比表格。可以看出，相较于全量加载，对字体进行截取后加载速度快了145 倍。 fontmin 是支持生成 woff2 文件的，但是官方文档并没有更新，最开始我使用的 woff 文件，但是 woff2 格式文件体积更小并且浏览器支持不错 字体名称 大小 时间 HanyiSentyWoodcut.ttf 48.2MB 17.41s HanyiSentyWoodcut.woff 21.7KB 0.19s HanyiSentyWoodcut.woff2 12.2KB 0.12s 二、字体加载完成前不展示预览内容这是在实现预览功能过程中的第二个问题。 在浏览器的字体显示行为中存在阻塞期和交换期两个概念，以 Chrome 为例，在字体加载完成前，会有一段时间显示空白，这段时间被称为阻塞期。如果在阻塞期内仍然没有加载完成，就会先显示后备字体，进入交换期，等待字体加载完成后替换。这就会导致页面字体出现闪烁，与我想要的效果不符。而 font-display 属性控制浏览器的这个行为，是否可以更换 font-display 属性的取值来达到我们的目的呢？ font-display Block Period Swap Period block Short Infinite swap None Infinite fallback Extremely Short Short optional Extremely Short None 字体的显示策略和 font-display 的取值有关，浏览器默认的 font-display 值为 auto，它的行为和取值 block 较为接近。 第一种策略是 FOIT(Flash of Invisible Text)，FOIT 是浏览器在加载字体的时候的默认表现形式，其规则如前文所说。 第二种策略是 FOUT(Flash of Unstyled Text)，FOUT 会指示浏览器使用后备字体直至自定义字体加载完成，对应的取值为 swap。 两种不同策略的应用：Google Fonts FOIT&emsp;汉仪字库 FOUT 在夸克项目中，我希望的效果是字体加载完成前不展示预览内容，FOIT 策略最为接近。但是 FOIT 文本内容不可见的最长时间大约是3s， 如果用户网络状况不太好，那么3s过后还是会先显示后备字体，导致页面字体闪烁，因此 font-display 属性不满足要求。 查阅资料得知，CSS Font Loading API 在 JavaScript 层面上也提供了解决方案： FontFace、FontFaceSet先看看它们的兼容性： 又是 IE，IE 没有用户不用管 我们可以通过 FontFace 构造函数构造出一个 FontFace 对象： const fontFace = new FontFace(family, source, descriptors) family 字体名称，指定一个名称作为 CSS 属性 font-family 的值， source 字体来源，可以是一个 url 或者 ArrayBuffer descriptors optional style：font-style weight：font-weight stretch：font-stretch display: font-display （这个值可以设置，但不会生效） unicodeRange：@font-face 规则的 unicode-ranges variant：font-variant featureSettings：font-feature-settings 构造出一个 fontFace 后并不会加载字体，必须执行 fontFace 的 load 方法。load 方法返回一个 promise，promise 的 resolve 值就是加载成功后的字体。但是仅仅加载成功还不会使这个字体生效，还需要将返回的 fontFace 添加到 fontFaceSet。 使用方法如下： 12345678/** * @param &#123;string&#125; path 字体文件路径 */async function loadFont(path) &#123; const fontFaceSet = document.fonts const fontFace = await new FontFace('fontFamily', `url('$&#123;path&#125;') format('woff2')`).load() fontFaceSet.add(fontFace)&#125; 因此，在客户端我们可以先设置文字内容的 CSS 为 opacity: 0，等待 await loadFont(path) 执行完毕后，再将 CSS 设置为 opacity: 1, 这样就可以控制在自定义字体加载未完成前不显示内容。 最后总结本文介绍了在开发字体预览功能时遇到的问题和解决方案，限于 OpenType 规范条目很多，在介绍 fontmin 原理部分，仅描述了对 glyf 表的处理，对此感兴趣的读者可进一步学习。 本次工作的回顾和总结过程中，也在思考更好的实现，如果你有建议欢迎和我交流。同时文章的内容是我个人的理解，存在错误难以避免，如果发现错误欢迎指正。 感谢阅读！ 参考 前端字体截取 Scalable Vector Graphics FontFace FontFaceSet fontmin fonteditor-core TrueType-Reference-Manual OpenType-Font-File","pubDate":"Fri, 28 Feb 2020 04:00:00 GMT","guid":"https://aotu.io/notes/2020/02/28/webfont-processing/","category":"Web开发"},{"title":"JDRD开发小结","link":"https://aotu.io/notes/2020/02/21/jdrd-summary/","description":"经过一个月的时间，在我遇到了很多“这个我不会做啊？”，“这个到底怎么做“的问题后，它终于成功上线了！下面总结一下整整一个月的时间我是如何开发JDRD，遇到的各种问题以及解决方案。 JDR DESIGN 是京东零售设计中台的门户站点，展示京东零售设计服务平台的产品以及应用场景，特点是动效丰富、图片细节多、要求整站文案和外链可配置。项目最大的困难就是动效开发复杂和开发排期紧凑的问题。 这是我入职以来负责的第一个项目，需要花大量时间来熟悉新的开发流程，项目排期非常紧凑，并且在排期完后又新增了窄版、骨架屏、首页图标动效、入场动画、产品页头部动效等新的需求，每天高强度的加班，回想起来虽然很难，但是非常有挑战性，非常有收获。 项目架构技术选型作为一个 9012 年的 PC 端项目，我们自然也需要非常先进的技术选型来帮助我们提升研发生产力，所以一个优秀的前端框架和一个高效的前端工程化工具，自然是必不可缺的选择。选择团队自研的 Nerv 进行开发，Nerv 是一个基于 virtual dom 的类 Reac t组件框架，比 React 更小的体积更高的性能，还保持了对 IE 浏览器的兼容，满足了 JDRD 需要兼容IE10的要求。 自动化前端构建工具选择了团队自研的前端工程化工具 Athena，简化 webpack 配置工作，帮助我们在项目中实现自动化编译、代码处理、依赖分析、文件压缩、文件 MD5 戳等需求。 项目整体架构在前端架构方面，根据上述的技术选型以及常见的前端体系，基于本项目的需求进行了些调整，整体架构设计如下： Athena 和 Nerv 上文已经介绍过，下面介绍一下另外几个： 通用工具库：基于以往的项目建立的公共函数库，包括 Slider、Lazyimg、Lazyload、Nerv-loadable 等。 NEOS 管理平台：将整站的文案和外链数据放在 NEOS 平台进行管理，简化文案修改等工作。 兜底展示： 在请求到错误链接时重定向到 error.html 页面 图片加载失败时展示兜底图 MTA 数据分析：将网站的所有点击事件添加埋点进行数据上报，根据实时数据统计分析服务，监控版本质量、渠道状况、用户画像属性及用户细分行为。 开发过程整个开发流程总结如下图所示： 既然是总结，开发过程中的流程当然没有这么完整，漏掉了一部分（已红色标注），导致开发到后面因为前面漏掉的环节，浪费了很多的时间。 整站设计规范：由于开发和设计是同时进行的，开始开发时只有首页定稿，没有其他页面的设计稿，以及窄版的规范，我们应该在开发前和设计师明确整站的设计规范，根据设计规范建立通用样式表，整站引入。 页面&amp;楼层结构：楼层的结构设计对于后续做楼层懒加载非常重要，根据设计稿的功能结构区分楼层。 兼容 IE：JDRD 是需要兼容 IE 的，一些不兼容 IE 的 API 和样式属性应该尽量避免使用。 骨架屏：骨架屏的高度和楼层间隔和内容是一致的，应该建立公共类，定义骨架屏和内容一致的样式，在后续调整内容时，不需要再去调整一遍骨架屏的样式。 数据埋点：交互稿其实有详细介绍哪些地方需要点击跳转的事件，开发时应该在定义点击跳转时就给数据埋点传参。 除了在开发流程中的问题外，最头疼的就是动效的开发了，下文会详细介绍。 项目优化性能优化性能优化的初衷就是加快网站的加载速度，让用户能够更快的看到内容，上面介绍到前端工程化工具 Athena 已经做到合并、压缩了静态资源文件，那还有什么方法能够缩小请求的静态资源体积，加快首屏的加载速度呢，我们尝试了以下性能优化手段。 楼层懒加载楼层懒加载就是按楼层划分组件，并进行代码切割，在页面滚动时按需加载组件。 Nerv-loadable 是一个专门用于动态 import 的 React 高阶组件，你可以把任何组件改写为支持动态 import 的形式，利用 import() 来进行动态加载。 1234567const NewsBannerLoadable = Loadable(&#123; loader: () =&gt; import(/* webpackChunkName: \"news_banner\" */ './news_banner'), loading: loadingPlaceholder.bind(null, loadingBlock), delay: 0&#125;); 上面的代码在首次加载时，会先展示一个 loadingBlock，然后动态加载 news_banner 的代码，组件代码加载完毕之后，便会替换掉 loadingBlock。Lazyload 通过监听 window 对象或者父级对象的 scroll 事件，触发 load，实现懒加载，让组件进入页面可视区时才加载该组件。需要注意的是 lazyload 需要设置高度，才会撑起懒加载的区域。 123&lt;Lazyload &#123;...this.lazyloadOptions&#125; height=&#123;this.floorHeight.newsBanner&#125;&gt; &lt;NewsBannerLoadable /&gt;&lt;/Lazyload&gt; 以首页为例，有四处组件是不需要首次加载的，而是使用动态加载：多端适配、物料、应用场景、设计思考。首次加载实际上只需要加载首屏的头部、视频、banner 即可。切分之后，首屏 js 体积缩减了 50KB。 图片懒加载整站图片非常多，为了保持清晰度而且全部采用二倍图引入，消耗资源比较大，为了加快加载速度，我们选择让滚动条滚动到图片的可视区后才加载该图片。 使用 Lazyload 实现，和上述组件懒加载介绍的一样， 包裹着需要懒加载的图片，就可以实现图片懒加载。 图片懒加载之外还有个优化，就是图片加载中、加载失败、加载成功的状态的判断，根据不同状态展示图片的内容。 使用 Lazyimg 实现这个功能： 使用 new Image() 创建一个新的 HTMLImageElement 实例 img.onload()，img.onerror() 捕获到图片加载成功或者失败的状态 加载中：显示兜底图 加载成功：显示加载到的图片 加载失败：显示兜底图 其他优化手段除了上面两点外，还可以从 webpack 打包进行性能优化，webpack 打包后会生成一个或多个包含源代码最终版本的“打包好的文件”，它们由 chunks 组成，SplitChunks 插件可以将公共依赖项提取到现有的 entry chunk 或全新的代码块中，进行代码切割，减小 chunks 包的大小。 体验优化骨架屏以往的传统网站一般会在加载中展示一个 loading 态，也可以达到占位的效果，但是 loading 动画和真实模块耦合度低，界面效果不够优美，JDRD 则是选用骨架屏进行占位，以灰色豆腐块的形式尽量缩小真实模块结构与加载占位之间的视觉差异。 骨架屏的两个用途： 组件加载完之前的占位 使用 Lazyload 懒加载楼层组件，加载中使用 Loadable 提前占位，占位符设置为骨架屏。 数据加载完之前的占位 设置组件的 state.loaded 初始值为 false ，数据加载成功时 state.loaded = true ，render 函数里如果 loaded === false ，则显示骨架屏。 骨架屏的实现方式有两种，一是下载并引入骨架屏插件（如 antd ），根据不同模块引入对应的骨架屏组件，这种方式和 loading 动画一样，耦合度低，但是全局通用，节省代码量。二是根据视觉稿写骨架屏的样式。JDRD 选择的是第二种，骨架屏和真实模块实现高度耦合。每个页面结构不一样，对应的骨架屏也是完全不同，骨架屏暂时不能抽成公共组件全局通用。 宽窄版首页定稿设定的宽度为 1240px ，对小屏不够友好，我们增加了一版窄版样式兼容小屏。 宽版和窄版开发的重点是定好通用的变量，包括字号粗细、宽窄版宽度、窄版尺寸比。这些通用样式规范需要和设计师统一规范，兼容窄版的开发就会变得非常简单。 只需要在两个地方判断宽窄版，给最顶层的标签加上 wide/narraw 类，在 narrow 下添加窄版的自定义样式。 在页面刚加载到时判断宽窄版，在加载到样式表之前给 html 标签添加 wide/narraw 123456789101112131415!function(e) &#123; window.pageConfig = &#123;&#125;; pageConfig.isWide = function() &#123; var n = e, i = document, o = i.documentElement, t = i.getElementsByTagName(\"body\")[0], a = n.innerWidth || o.clientWidth || t.clientWidth; return a &gt;= 1300 &#125; (); var n = []; pageConfig.isWide ? (n.push(\"wide\")) : n.push(\"narrow\"); var i = document.getElementsByTagName(\"html\")[0]; i.className = n.join(\" \")&#125; (window, void 0); 文档视图调整大小时判断宽窄版，修改 html 标签的 className 先引入 Events.js ，然后在 componentDidMount 里生命周期函数里绑定 ‘ isWideChange ‘ 事件，在文档视图宽度达到宽窄版临界点时调用。 1234567componentDidMount() &#123; window._.eventCenter.on('isWideChange', evt =&gt; &#123; this.setState(&#123;//更新state,更新视图 isWide: evt.detail.isWide &#125;); &#125;);&#125; 动效开发首页图标动效为了突出设计理念，首页图标动效包含大量位移、旋转、缩放、形变、路径动画等细节，由始末动画+循环动画合成，传统做法是 css3 实现，这需要逐帧写动画细节，工作量非常大，我们尝试使用 Lottie 直接解析从 AE 导出的 json 格式的动画（方案由燕婷提出），发现能够完全还原AE动画。 Lottie 是 Airbnb 开源的一套跨平台的完整的动画效果解决方案，可实时渲染 After Effects 动画，从而使应用程序可以像使用静态图像一样轻松地使用动画。这样实现起来就非常简单了。分以下两步： 在 AE 软件中用 bodymovin 插件将动画导出为 json 文件 在项目中使用 lottie-web 将 json 格式的动画解析为 SVG（使用文档） lottie-web 文档中的方法非常全面，JDRD 图标动效使用加载动画、播放指定帧区间、反向播放动画方法，就实现了起始动画 20 帧+循环动画 60 帧+起始动画反向播放 20 帧的动画合成操作。 项目示例代码如下： 1234567891011121314npm install lottie-web //安装lottie-webimport lottie from 'lottie-web' //引入lottie-web到项目中//lottie-web常用方法this.anim = lottie.loadAnimation(&#123; //加载动画 container: element, renderer: 'svg', loop: true, autoplay: true, path: 'data.json'&#125;);this.anim.playSegments([[0,60]], true); //播放指定帧区间this.anim.setDirection(-1);//动画反向播放this.anim.play();//播放动画this.anim.pause()//暂停动画 经过以上两步，Lottie 已经将一个 AE 格式的动画渲染在 web 页面上。 这里有 2 个需要注意的点： json 文件的引入要使用 CDN，引入本地 json 文件会解析失败。 如果动画源文件中有引入图片文件，bodymovin 导出的动画为 json+img。图片动画的兼容性有待确认。 以上就是用 Lottie 实现的动画，看到这里，是不是觉得 so easy，但是 Lottie 并不是万能的，不能解析所有的动画特性，开发前需要先看下支持列表。并和设计师确认是否都支持。 入场动画JDRD 整站采用了骨架屏占位，那么入场动画最大的问题就是如何让它不和骨架屏冲突，解决方法就是楼层懒加载里面，再加一层入场动画的组件懒加载，两层懒加载的设置 offset 差，就可以做到在可视区外加载楼层组件，在可视区内播放入场动画。具体实现如下： 楼层懒加载，在页面滚动时按需加载楼层组件 12345678// 在距离底部200px时，加载楼层组件getMaterialLoadable()&#123; return this.getFloor( &lt;Lazyload lazyloadOptions=&#123;offset: 200&#125; height=&#123;1000&#125;&gt; &lt;MaterialLoadable /&gt; &lt;/Lazyload&gt; );&#125; 楼层中的入场动画组件懒加载 1234567// 在距离底部-200px时，加载入场动画组件，这时因为楼层组件已经加载过了，页面显示是真实组件而不是骨架屏&lt;Lazyload lazyloadOptions=&#123;offset: -200&#125;&gt; &lt;div className=\"w\"&gt; &lt;IndexTitle showLine=&#123;true&#125; title=&#123;this.state.title&#125;&gt;&lt;/IndexTitle&gt; &#123;this.renderMaterial()&#125; &lt;/div&gt;&lt;/Lazyload&gt; 另外一个难点是序列动画的效果，序列动画就是将列表元素的动画执行时机错开，具体实现参考css3 animation 属性众妙。实现代码如下： 12345@for $i from 1 to 6 &#123; .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-1+$i)*0.1s; /*计算每个元素的 animation-delay */ &#125;&#125; 产品页头部动效产品页的头部动效分两部分，氛围动效 + 波浪动效。 氛围动效 氛围动效的实现比较简单，也是使用 Lottie 实现，这里遇到了 Lottie 不支持的特性，就是渐变，对于不支持的特性，我们可以拿到需要自定义样式的标签的 id，自定义样式，如图所示： 12345678#__lottie_element_369 &#123; stop[offset=\"0%\"] &#123; stop-color: #FDFDFF; &#125; stop[offset=\"100%\"] &#123; stop-color: #F7F7FB; &#125;&#125; 自定义样式的时候，这里有个坑一定要注意，SVG 的 ID 是会变的，例如开发时，这个 ID 是 100，测试时这个 ID 有可能变成 101，这个是偶现的，目前还没有找到 ID 值 + 1 的原因，但是为了让自定义的样式生效，需要给 ID 为 100 和 ID 为 101 的标签都加上样式。 波浪动效 通过引入正弦波浪动效库 sine_wave 实现。sine_wave 使用 canvas 元素生成多个可配置的正弦波，这样我们就可以通过配置参数得到想要的正弦波浪，具体实现如下： 1234567891011121314151617181920212223new SineWaves(&#123; el: document.getElementById( `waves`),//dom speed: 0.75,//速度 width: function() &#123;//canvas宽度 return document.body.clientWidth; &#125;, height: 68,//canvas高度 ease: 'Linear',//动画曲线 waves: [//需要配置的正弦波浪 &#123; \"timeModifier\":1,//速度 \"lineWidth\":1,//线条宽度 \"amplitude\":30 * window.devicePixelRatio,//波浪高度 \"wavelength\":125 * window.devicePixelRatio,//波长 \"strokeStyle\":\"rgba(221,221,233,1)\",//颜色 \"type\": function(x, waves) &#123;//自定义波浪类型 return waves.sine(x); // Combine two together &#125; &#125; ], rotate: 0,//旋转角度 wavesWidth: '400%',//波浪宽度&#125;); 根据文档介绍的参数来看，有两个参数是实现 3D 旋转波浪效果的关键： type，自定义波浪的类型，可以修改 x 轴的位移，让 3 根波浪错位，实现旋转的效果。 123type: function(x, waves) &#123; return waves.sine(x+8); // Combine two together&#125; wavelength，波浪长度，3 根弧度一模一样的波浪明显是不符合要求的，只需要将红色的波浪的弧长加长，就可以实现一根波浪环绕另外两根波浪的效果。 开发过程中发现 sine_waves 的一个显示问题，它以默认二倍屏的方式定义的 canvas，这样在一倍屏下波浪是有问题的，解决方法是在参数波浪高度 amplitude 和波长 wavelength 根据 window.devicePixelRatio 来定义。 1234&#123; \"amplitude\":30 * window.devicePixelRatio,//波浪高度 \"wavelength\":125 * window.devicePixelRatio,//波长&#125; 全局细节动效最后介绍的就是全局细节动效的优化，为了让整站的动效流畅，平滑的过渡，做了以下工作： 用 SASS 变量 $common_animation 管理通用动画，让整站动画一致化 图标动效和边框动效采用 SVG 实现，实现动画组件化的同时，矢量元素不失真 需要过渡的元素，用 visibility 代替 display 控制元素的显示隐藏 整体总结本文从项目架构、开发流程、项目优化 3 个方面阐述 JDRD 官网的开发过程，中间遇到了太多问题，在问题的解决过程中记录和总结，是收获满满的喜悦，也发现了一些可以优化的模块，让下次能够做得更好，在开发过程中的多些思考和探究，最优化的设计项目。 感谢阅读！","pubDate":"Fri, 21 Feb 2020 07:24:00 GMT","guid":"https://aotu.io/notes/2020/02/21/jdrd-summary/","category":"项目总结"},{"title":"Taro Next 发布预览版：同时支持 React / Vue / Nerv","link":"https://aotu.io/notes/2020/02/03/taro-next-alpha/","description":"自 Taro 2.0 起，我们将会启动对整个 Taro 系统架构的革新，这次革新我们将其称之为 Taro Next。Taro Next 革新完成之后，Taro 本身的拓展性、稳定性、可维护性都会大幅提高，相应地，使用 Taro 的开发者也会获得更好的开发体验，降低更多开发成本和学习成本。 我们目前已经完成了编译系统和小程序端的重构，通过 npm i -g @tarojs/cli@next 安装 Taro CLI 预览（alpha）版之后，使用 taro init 创建新项目即可体验 Taro Next 的新特性： 同时支持 React/Vue/Nerv 三种框架在旧版本的 Taro，我们以微信小程序的开发规范为基准，使用 React/JSX 的方式来进行开发。而在 Taro Next，我们把这一思路量化为一个编程模型： 设微信小程序生命周期为一个 interface，不同的框架实例的生命周期虽然不尽相同，但我们可以根据框架生命周期分别新建一个 class 去 implements 小程序生命周期的 interface。相应地，小程序的组件/API/路由规范可以使用同样的思路和模型让不同框架的代码，运行在不同的端上： 不限制语言、语法由于 Taro Next 的架构出现了变化，表面上来看 Taro 从一个编译型框架变成了一个运行时框架。但究其内核是整体的设计思路出现了变化：从前是「模拟（mock）」，现在是「实现（implements）」。在 Taro Next 我们实现了 React 在小程序中的完整支持，因此这类曾经的 Taro 无法运行的代码在 Taro Next 中完全没有压力： 12345import &#123; View &#125; from '@tarojs/components'function Page (props) &#123; const view = React.createElement(View, null, props.text) return [view, React.Children.only(this.props.children)]&#125; 在旧版本的 Taro 中我们对 JavaScript 和 TypeScript 进行了 First Class 的支持，Taro Next 我们更进一步，原理上最终可以编译到 JavaScript 的语言都可以用来构建 Taro 项目，以下是一个在 Vue 中使用 CoffeeScript 的例子： 12345678910111213// config.js&#123; webpackChain (chain) &#123; chain.merge(&#123; module: &#123; rule: &#123; test: /\\.coffee$/, use: [ 'coffee-loader' ] &#125; &#125; &#125;) &#125;&#125; 123456789101112131415&lt;template&gt; &lt;view&gt;&#123;&#123; title &#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123; text &#125;&#125;&lt;/view&gt; &lt;input v-model='text' /&gt;&lt;/template&gt;&lt;script lang=\"coffee\"&gt;export default props: title: type: String required: true data: -&gt; text: 'text'&lt;/script&gt; 更快的运行速度运行时性能主要分为两个部分，一是更新性能，二是初始化性能。 对于更新性能而言，旧版本的 Taro 会把开发者 setState 的数据进行一次全量的 diff，最终返回给小程序是按路径更新的 data。而在 Taro Next 中 diff 的工作交给了开发者使用的框架（React/Nerv/Vue），而框架 diff 之后的数据也会通过 Taro 按路径去最小化更新。因此开发者可以根据使用框架的特性进行更多更细微的性能优化。 初始化性能则是 Taro Next 的痛点。原生小程序或编译型框架的初始数据可以直接用于渲染，但 Taro Next 在初始化时会把框架的渲染数据转化为小程序的渲染数据，多了一次 setData 开销。 为了解决这个问题，Taro 从服务端渲染受到启发，在 Taro CLI 将页面初始化的状态直接渲染为无状态的 wxml，在框架和业务逻辑运行之前执行渲染流程。我们将这一技术称之为预渲染（Prerender），经过 Prerender 的页面初始渲染速度通常会和原生小程序一致甚至更快。 更快的构建速度和 source-map 支持作为一个编译型框架，旧版本的 Taro 会进行大量的 AST 操作，这类操作显著地拖慢了 Taro CLI 的编译速度。而在 Taro Next 中不会操作任何开发者代码的 AST，因此编译速度得到了大幅的提高。 正因为 AST 操作的取消，Taro Next 也轻松地实现了 source-map 的支持。这对于开发体验是一个巨大的提升： 不忘初心在做到以上各项特性的同时，我们也没有丢掉原来就已经支持的特性： 支持微信小程序、百度智能小程序、支付宝小程序、QQ 小程序、字节跳动小程序 使用原生小程序第三方组件/插件 多端条件编译 跨端 API 和样式处理 这些特性基本涉及到了小程序开发的方方面面，虽然是预览版，但 Taro Next 已经具备了开发生产级小程序的准备，在 Taro 团队内部和兄弟团队也有多款小程序正在使用 Taro Next 进行开发。而在 Taro Next 的 H5 端和移动端，我们还在进行紧张的开发。当 Taro Next 测试（beta）版发布时，使用 Taro Next 构建的一套代码，就可以同时运行在各种小程序、快应用、H5 和移动端当中。在未来，我们还会把 Taro Next 的能力开放出去，让开发者只要写少量的接入代码，就可以使用自己喜欢的任意框架（Angular, Flutter, svelte…）开发小程序或多端应用。 牢记使命正如我们在 Taro 2.0 发布时所言： 节物风光不相待，桑田碧海须臾改。 20 年代呼啸而来，下一个 10 年，很多框架都会死去，很多技术也会焕然而生，没有什么是不变的，唯一不变的只有变化，我们能做的也只能是拥抱变化。 前端技术一直在高速发展，流行的技术和框架每年都各不相同。但我们始终没有忘记开发 Taro 的初心和使命：降低开发成本，提高开发体验和开发效率。 「不忘初心，牢记使命。」 这就是 Taro 团队拥抱变化的方式。 参考资料[1] 小程序跨框架开发的探索与实践: https://www.infoq.cn/article/TMqBzVFTSiQTUbgxydPm [2] Taro Next 旧版本迁移指南：https://taro-docs.jd.com/taro/next/docs/migration.html [3] Prerender: https://taro-docs.jd.com/taro/next/docs/prerender.html [4] 性能测试：https://github.com/NervJS/taro-benchmark/tree/next [5] 与其它新型小程序的对比：https://taro-docs.jd.com/taro/next/docs/difference-to-others.html","pubDate":"Mon, 03 Feb 2020 05:50:00 GMT","guid":"https://aotu.io/notes/2020/02/03/taro-next-alpha/","category":"Web开发"}]}